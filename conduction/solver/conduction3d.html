<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>conduction.solver.conduction3d API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>conduction.solver.conduction3d</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">try: range = xrange
except: pass

import numpy as np
from petsc4py import PETSc
from mpi4py import MPI
comm = MPI.COMM_WORLD

class Conduction3D(object):
    &#34;&#34;&#34;
    Implicit 3D steady-state heat equation solver over a structured grid using PETSc
    &#34;&#34;&#34;

    def __init__(self, minCoord, maxCoord, res):

        minX, minY, minZ = tuple(minCoord)
        maxX, maxY, maxZ = tuple(maxCoord)
        resI, resJ, resK = tuple(res)


        dm = PETSc.DMDA().create(dim=3, sizes=[resI, resJ, resK], stencil_width=1, comm=comm)
        dm.setUniformCoordinates(minX, maxX, minY, maxY, minZ, maxZ)

        self.dm = dm
        self.lvec = dm.createLocalVector()
        self.gvec = dm.createGlobalVector()
        self.rhs = dm.createGlobalVector()
        self.lgmap = dm.getLGMap()

        # Setup matrix sizes
        self.sizes = self.gvec.getSizes()

        Nx, Ny, Nz = dm.getSizes()
        N = Nx*Ny*Nz

        dx = (maxX - minX)/(Nx - 1)
        dy = (maxY - minY)/(Ny - 1)
        dz = (maxZ - minZ)/(Nz - 1)

        # include ghost nodes in local domain
        (minI, maxI), (minJ, maxJ), (minK, maxK) = dm.getGhostRanges()

        nx = maxI - minI
        ny = maxJ - minJ
        nz = maxK - minK

        self.dx, self.dy, self.dz = dx, dy, dz
        self.nx, self.ny, self.nz = nx, ny, nz

        # local numbering
        self.nodes = np.arange(0, nx*ny*nz, dtype=PETSc.IntType)


        self._initialise_mesh_variables()
        self._initialise_boundary_dictionary()
        self._initialise_matrix()



    def _initialise_mesh_variables(self):

        # local coordinates
        self.coords = self.dm.getCoordinatesLocal().array.reshape(-1,3)

        minX, minY, minZ = self.coords.min(axis=0)
        maxX, maxY, maxZ = self.coords.max(axis=0)

        self.minX, self.maxX = minX, maxX
        self.minY, self.maxY = minY, maxY
        self.minZ, self.maxZ = minZ, maxZ

        # thermal properties
        self.diffusivity  = None
        self.heat_sources = None


    def _initialise_boundary_dictionary(self):
        # Setup boundary dictionary
        self.bc = dict()
        self.bc[&#34;maxY&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dy, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,1]==self.maxY}
        self.bc[&#34;minY&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dy, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,1]==self.minY}
        self.bc[&#34;minX&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dx, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,0]==self.minX}
        self.bc[&#34;maxX&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dx, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,0]==self.maxX}
        self.bc[&#34;minZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dz, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,2]==self.minZ}
        self.bc[&#34;maxZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dz, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,2]==self.maxZ}


        self.dirichlet_mask = np.zeros(self.nx*self.ny*self.nz, dtype=bool)


    def _initialise_matrix(self):
        # read into matrix
        self.mat = PETSc.Mat().create(comm=comm)
        self.mat.setType(&#39;aij&#39;)
        self.mat.setSizes(self.sizes)
        self.mat.setLGMap(self.lgmap)
        self.mat.setFromOptions()
        self.mat.setPreallocationNNZ((7,6))


    def update_properties(self, diffusivity, heat_sources):
        &#34;&#34;&#34;
        Update diffusivity and heat sources
        &#34;&#34;&#34;

        self.diffusivity = np.asarray(diffusivity)
        self.heat_sources = np.asarray(heat_sources)


    def boundary_condition(self, wall, val, flux=True):
        &#34;&#34;&#34;
        Set the boundary conditions on each wall of the domain.
        By default each wall is a Neumann (flux) condition.
        If flux=True, positive val indicates a flux vector towards the centre
        of the domain.

        val can be a vector with the same number of elements as the wall
        &#34;&#34;&#34;


        # (minX, maxX), (minY, maxY), (minZ, maxZ)

        if self.bc.has_key(str(wall)):
            self.bc[str(wall)][&#34;val&#34;]  = val
            self.bc[str(wall)][&#34;flux&#34;] = flux
            d = self.bc[str(wall)]

            mask = d[&#39;mask&#39;]

            if flux:
                self.dirichlet_mask[mask] = False                
                self.bc[str(wall)][&#34;val&#34;] /= -d[&#39;delta&#39;]
            else:
                self.dirichlet_mask[mask] = True

        else:
            raise ValueError(&#34;Wall should be one of &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, &#39;right&#39;&#34;)



    def construct_matrix(self, in_place=True, derivative=False):
        &#34;&#34;&#34;
        Construct the coefficient matrix
        i.e. matrix A in Ax = b

        We vectorise the 7-point stencil for fast matrix insertion.
        An extra border of dummy values around the domain allows for automatic
        Neumann (flux) boundary creation.
        These are stomped on if there are any Dirichlet conditions.

        &#34;&#34;&#34;

        if in_place:
            mat = self.mat
        else:
            mat = PETSc.Mat().create(comm=comm)
            mat.setType(&#39;aij&#39;)
            mat.setSizes(self.sizes)
            mat.setLGMap(self.lgmap)
            mat.setFromOptions()
            mat.setPreallocationNNZ((7,comm.size-1))

        nodes = self.nodes
        nx, ny, nz = self.nx, self.ny, self.nz
        n = nx*ny*nz

        adx = 1.0/(2*self.dx**2)
        ady = 1.0/(2*self.dy**2)
        adz = 1.0/(2*self.dz**2)

        u = self.diffusivity.reshape(nz,ny,nx)

        k = np.zeros((nz+2, ny+2, nx+2))
        k[1:-1,1:-1,1:-1] = u

        index = np.empty((nz+2, ny+2, nx+2), dtype=PETSc.IntType)
        index.fill(-1)
        index[1:-1,1:-1,1:-1] = nodes.reshape(nz,ny,nx)

        rows = np.empty((7,n), dtype=PETSc.IntType)
        cols = np.empty((7,n), dtype=PETSc.IntType)
        vals = np.empty((7,n))

        dirichlet_mask = self.dirichlet_mask


        closure = [(0,-2), (1,-1), (1,-1), (2,0), (1,-1), (1,-1), (1,-1)]
        #         N    W    F    S    E    B    C
        delta = [ady, adx, adz, ady, adx, adz, 0.0]

        for i in range(7):
            rs, re = closure[i]
            cs, ce = closure[-1+i]
            ds, de = closure[-2+i]

            rows[i] = nodes
            cols[i] = index[ds:nz+de+2,rs:ny+re+2,cs:nx+ce+2].ravel()
            vals[i] = delta[i]*(k[ds:nz+de+2,rs:ny+re+2,cs:nx+ce+2] + u).ravel()


        # Dirichlet boundary conditions (duplicates are summed)
        cols[:,dirichlet_mask] = nodes[dirichlet_mask]
        vals[:,dirichlet_mask] = 0.0

        # zero off-grid coordinates
        vals[cols &lt; 0] = 0.0

        # centre point
        vals[-1] = 0.0
        if derivative:
            vals[-1][dirichlet_mask] = 0.
        else:
            vals[-1][dirichlet_mask] = -1.0


        row = rows.ravel()
        col = cols.ravel()
        val = vals.ravel()


        # mask off-grid entries and sum duplicates
        mask = col &gt; -1
        row, col, val = sum_duplicates(row[mask], col[mask], val[mask])


        # indptr, col, val = coo_tocsr(row, col, val)
        nnz = np.bincount(row)
        indptr = np.insert(np.cumsum(nnz),0,0)

        mat.assemblyBegin()
        mat.setValuesLocalCSR(indptr.astype(PETSc.IntType), col, val)
        mat.assemblyEnd()

        # set diagonal vector
        diag = mat.getRowSum()
        diag.scale(-1.0)
        mat.setDiagonal(diag)

        return mat


    def construct_rhs(self, in_place=True):
        &#34;&#34;&#34;
        Construct the right-hand-side vector
        i.e. vector b in Ax = b

        Boundary conditions are grabbed from the dictionary and
        summed to the rhs.
        Be careful of duplicate entries on the corners!!
        &#34;&#34;&#34;
        if in_place:
            rhs = self.rhs
        else:
            rhs = self.gvec.duplicate()
        
        vec = -1.0*self.heat_sources.copy()

        for wall in self.bc:
            val  = self.bc[wall][&#39;val&#39;]
            flux = self.bc[wall][&#39;flux&#39;]
            mask = self.bc[wall][&#39;mask&#39;]
            if flux:
                vec[mask] += val
            else:
                vec[mask] = val

        self.lvec.setArray(vec)
        self.dm.localToGlobal(self.lvec, rhs)

        return rhs


    def solve(self, solver=&#39;gmres&#39;):
        &#34;&#34;&#34;
        Construct the matrix A and vector b in Ax = b
        and solve for x

        GMRES method is default
        &#34;&#34;&#34;
        matrix = self.construct_matrix()
        rhs = self.construct_rhs()
        res = self.dm.createGlobalVector()

        ksp = PETSc.KSP().create(comm=comm)
        ksp.setType(solver)
        ksp.setOperators(matrix)
        ksp.setFromOptions()
        ksp.setTolerances(1e-10, 1e-50)
        ksp.solve(rhs, res)
        return res.array



def csr_tocoo(indptr, indices, data):
    &#34;&#34;&#34; Convert from CSR to COO sparse matrix format &#34;&#34;&#34;
    d = np.diff(indptr)
    I = np.repeat(np.arange(0,d.size,dtype=&#39;int32&#39;), d)
    return I, indices, data

def coo_tocsr(I, J, V):
    &#34;&#34;&#34; Convert from COO to CSR sparse matrix format &#34;&#34;&#34;
    nnz = np.bincount(I)
    indptr = np.insert(np.cumsum(nnz),0,0)
    return indptr, J, V

def sum_duplicates(I, J, V):
    &#34;&#34;&#34;
    Sum all duplicate entries in the matrix
    &#34;&#34;&#34;
    order = np.lexsort((J, I))
    I, J, V = I[order], J[order], V[order]
    unique_mask = ((I[1:] != I[:-1]) |
                   (J[1:] != J[:-1]))
    unique_mask = np.append(True, unique_mask)
    unique_inds, = np.nonzero(unique_mask)
    return I[unique_mask], J[unique_mask], np.add.reduceat(V, unique_inds)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="conduction.solver.conduction3d.coo_tocsr"><code class="name flex">
<span>def <span class="ident">coo_tocsr</span></span>(<span>I, J, V)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from COO to CSR sparse matrix format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coo_tocsr(I, J, V):
    &#34;&#34;&#34; Convert from COO to CSR sparse matrix format &#34;&#34;&#34;
    nnz = np.bincount(I)
    indptr = np.insert(np.cumsum(nnz),0,0)
    return indptr, J, V</code></pre>
</details>
</dd>
<dt id="conduction.solver.conduction3d.csr_tocoo"><code class="name flex">
<span>def <span class="ident">csr_tocoo</span></span>(<span>indptr, indices, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from CSR to COO sparse matrix format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csr_tocoo(indptr, indices, data):
    &#34;&#34;&#34; Convert from CSR to COO sparse matrix format &#34;&#34;&#34;
    d = np.diff(indptr)
    I = np.repeat(np.arange(0,d.size,dtype=&#39;int32&#39;), d)
    return I, indices, data</code></pre>
</details>
</dd>
<dt id="conduction.solver.conduction3d.sum_duplicates"><code class="name flex">
<span>def <span class="ident">sum_duplicates</span></span>(<span>I, J, V)</span>
</code></dt>
<dd>
<div class="desc"><p>Sum all duplicate entries in the matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_duplicates(I, J, V):
    &#34;&#34;&#34;
    Sum all duplicate entries in the matrix
    &#34;&#34;&#34;
    order = np.lexsort((J, I))
    I, J, V = I[order], J[order], V[order]
    unique_mask = ((I[1:] != I[:-1]) |
                   (J[1:] != J[:-1]))
    unique_mask = np.append(True, unique_mask)
    unique_inds, = np.nonzero(unique_mask)
    return I[unique_mask], J[unique_mask], np.add.reduceat(V, unique_inds)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="conduction.solver.conduction3d.Conduction3D"><code class="flex name class">
<span>class <span class="ident">Conduction3D</span></span>
<span>(</span><span>minCoord, maxCoord, res)</span>
</code></dt>
<dd>
<div class="desc"><p>Implicit 3D steady-state heat equation solver over a structured grid using PETSc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conduction3D(object):
    &#34;&#34;&#34;
    Implicit 3D steady-state heat equation solver over a structured grid using PETSc
    &#34;&#34;&#34;

    def __init__(self, minCoord, maxCoord, res):

        minX, minY, minZ = tuple(minCoord)
        maxX, maxY, maxZ = tuple(maxCoord)
        resI, resJ, resK = tuple(res)


        dm = PETSc.DMDA().create(dim=3, sizes=[resI, resJ, resK], stencil_width=1, comm=comm)
        dm.setUniformCoordinates(minX, maxX, minY, maxY, minZ, maxZ)

        self.dm = dm
        self.lvec = dm.createLocalVector()
        self.gvec = dm.createGlobalVector()
        self.rhs = dm.createGlobalVector()
        self.lgmap = dm.getLGMap()

        # Setup matrix sizes
        self.sizes = self.gvec.getSizes()

        Nx, Ny, Nz = dm.getSizes()
        N = Nx*Ny*Nz

        dx = (maxX - minX)/(Nx - 1)
        dy = (maxY - minY)/(Ny - 1)
        dz = (maxZ - minZ)/(Nz - 1)

        # include ghost nodes in local domain
        (minI, maxI), (minJ, maxJ), (minK, maxK) = dm.getGhostRanges()

        nx = maxI - minI
        ny = maxJ - minJ
        nz = maxK - minK

        self.dx, self.dy, self.dz = dx, dy, dz
        self.nx, self.ny, self.nz = nx, ny, nz

        # local numbering
        self.nodes = np.arange(0, nx*ny*nz, dtype=PETSc.IntType)


        self._initialise_mesh_variables()
        self._initialise_boundary_dictionary()
        self._initialise_matrix()



    def _initialise_mesh_variables(self):

        # local coordinates
        self.coords = self.dm.getCoordinatesLocal().array.reshape(-1,3)

        minX, minY, minZ = self.coords.min(axis=0)
        maxX, maxY, maxZ = self.coords.max(axis=0)

        self.minX, self.maxX = minX, maxX
        self.minY, self.maxY = minY, maxY
        self.minZ, self.maxZ = minZ, maxZ

        # thermal properties
        self.diffusivity  = None
        self.heat_sources = None


    def _initialise_boundary_dictionary(self):
        # Setup boundary dictionary
        self.bc = dict()
        self.bc[&#34;maxY&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dy, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,1]==self.maxY}
        self.bc[&#34;minY&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dy, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,1]==self.minY}
        self.bc[&#34;minX&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dx, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,0]==self.minX}
        self.bc[&#34;maxX&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dx, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,0]==self.maxX}
        self.bc[&#34;minZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dz, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,2]==self.minZ}
        self.bc[&#34;maxZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: self.dz, &#34;flux&#34;: True, &#34;mask&#34;: self.coords[:,2]==self.maxZ}


        self.dirichlet_mask = np.zeros(self.nx*self.ny*self.nz, dtype=bool)


    def _initialise_matrix(self):
        # read into matrix
        self.mat = PETSc.Mat().create(comm=comm)
        self.mat.setType(&#39;aij&#39;)
        self.mat.setSizes(self.sizes)
        self.mat.setLGMap(self.lgmap)
        self.mat.setFromOptions()
        self.mat.setPreallocationNNZ((7,6))


    def update_properties(self, diffusivity, heat_sources):
        &#34;&#34;&#34;
        Update diffusivity and heat sources
        &#34;&#34;&#34;

        self.diffusivity = np.asarray(diffusivity)
        self.heat_sources = np.asarray(heat_sources)


    def boundary_condition(self, wall, val, flux=True):
        &#34;&#34;&#34;
        Set the boundary conditions on each wall of the domain.
        By default each wall is a Neumann (flux) condition.
        If flux=True, positive val indicates a flux vector towards the centre
        of the domain.

        val can be a vector with the same number of elements as the wall
        &#34;&#34;&#34;


        # (minX, maxX), (minY, maxY), (minZ, maxZ)

        if self.bc.has_key(str(wall)):
            self.bc[str(wall)][&#34;val&#34;]  = val
            self.bc[str(wall)][&#34;flux&#34;] = flux
            d = self.bc[str(wall)]

            mask = d[&#39;mask&#39;]

            if flux:
                self.dirichlet_mask[mask] = False                
                self.bc[str(wall)][&#34;val&#34;] /= -d[&#39;delta&#39;]
            else:
                self.dirichlet_mask[mask] = True

        else:
            raise ValueError(&#34;Wall should be one of &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, &#39;right&#39;&#34;)



    def construct_matrix(self, in_place=True, derivative=False):
        &#34;&#34;&#34;
        Construct the coefficient matrix
        i.e. matrix A in Ax = b

        We vectorise the 7-point stencil for fast matrix insertion.
        An extra border of dummy values around the domain allows for automatic
        Neumann (flux) boundary creation.
        These are stomped on if there are any Dirichlet conditions.

        &#34;&#34;&#34;

        if in_place:
            mat = self.mat
        else:
            mat = PETSc.Mat().create(comm=comm)
            mat.setType(&#39;aij&#39;)
            mat.setSizes(self.sizes)
            mat.setLGMap(self.lgmap)
            mat.setFromOptions()
            mat.setPreallocationNNZ((7,comm.size-1))

        nodes = self.nodes
        nx, ny, nz = self.nx, self.ny, self.nz
        n = nx*ny*nz

        adx = 1.0/(2*self.dx**2)
        ady = 1.0/(2*self.dy**2)
        adz = 1.0/(2*self.dz**2)

        u = self.diffusivity.reshape(nz,ny,nx)

        k = np.zeros((nz+2, ny+2, nx+2))
        k[1:-1,1:-1,1:-1] = u

        index = np.empty((nz+2, ny+2, nx+2), dtype=PETSc.IntType)
        index.fill(-1)
        index[1:-1,1:-1,1:-1] = nodes.reshape(nz,ny,nx)

        rows = np.empty((7,n), dtype=PETSc.IntType)
        cols = np.empty((7,n), dtype=PETSc.IntType)
        vals = np.empty((7,n))

        dirichlet_mask = self.dirichlet_mask


        closure = [(0,-2), (1,-1), (1,-1), (2,0), (1,-1), (1,-1), (1,-1)]
        #         N    W    F    S    E    B    C
        delta = [ady, adx, adz, ady, adx, adz, 0.0]

        for i in range(7):
            rs, re = closure[i]
            cs, ce = closure[-1+i]
            ds, de = closure[-2+i]

            rows[i] = nodes
            cols[i] = index[ds:nz+de+2,rs:ny+re+2,cs:nx+ce+2].ravel()
            vals[i] = delta[i]*(k[ds:nz+de+2,rs:ny+re+2,cs:nx+ce+2] + u).ravel()


        # Dirichlet boundary conditions (duplicates are summed)
        cols[:,dirichlet_mask] = nodes[dirichlet_mask]
        vals[:,dirichlet_mask] = 0.0

        # zero off-grid coordinates
        vals[cols &lt; 0] = 0.0

        # centre point
        vals[-1] = 0.0
        if derivative:
            vals[-1][dirichlet_mask] = 0.
        else:
            vals[-1][dirichlet_mask] = -1.0


        row = rows.ravel()
        col = cols.ravel()
        val = vals.ravel()


        # mask off-grid entries and sum duplicates
        mask = col &gt; -1
        row, col, val = sum_duplicates(row[mask], col[mask], val[mask])


        # indptr, col, val = coo_tocsr(row, col, val)
        nnz = np.bincount(row)
        indptr = np.insert(np.cumsum(nnz),0,0)

        mat.assemblyBegin()
        mat.setValuesLocalCSR(indptr.astype(PETSc.IntType), col, val)
        mat.assemblyEnd()

        # set diagonal vector
        diag = mat.getRowSum()
        diag.scale(-1.0)
        mat.setDiagonal(diag)

        return mat


    def construct_rhs(self, in_place=True):
        &#34;&#34;&#34;
        Construct the right-hand-side vector
        i.e. vector b in Ax = b

        Boundary conditions are grabbed from the dictionary and
        summed to the rhs.
        Be careful of duplicate entries on the corners!!
        &#34;&#34;&#34;
        if in_place:
            rhs = self.rhs
        else:
            rhs = self.gvec.duplicate()
        
        vec = -1.0*self.heat_sources.copy()

        for wall in self.bc:
            val  = self.bc[wall][&#39;val&#39;]
            flux = self.bc[wall][&#39;flux&#39;]
            mask = self.bc[wall][&#39;mask&#39;]
            if flux:
                vec[mask] += val
            else:
                vec[mask] = val

        self.lvec.setArray(vec)
        self.dm.localToGlobal(self.lvec, rhs)

        return rhs


    def solve(self, solver=&#39;gmres&#39;):
        &#34;&#34;&#34;
        Construct the matrix A and vector b in Ax = b
        and solve for x

        GMRES method is default
        &#34;&#34;&#34;
        matrix = self.construct_matrix()
        rhs = self.construct_rhs()
        res = self.dm.createGlobalVector()

        ksp = PETSc.KSP().create(comm=comm)
        ksp.setType(solver)
        ksp.setOperators(matrix)
        ksp.setFromOptions()
        ksp.setTolerances(1e-10, 1e-50)
        ksp.solve(rhs, res)
        return res.array</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="conduction.solver.conduction3d.Conduction3D.boundary_condition"><code class="name flex">
<span>def <span class="ident">boundary_condition</span></span>(<span>self, wall, val, flux=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the boundary conditions on each wall of the domain.
By default each wall is a Neumann (flux) condition.
If flux=True, positive val indicates a flux vector towards the centre
of the domain.</p>
<p>val can be a vector with the same number of elements as the wall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundary_condition(self, wall, val, flux=True):
    &#34;&#34;&#34;
    Set the boundary conditions on each wall of the domain.
    By default each wall is a Neumann (flux) condition.
    If flux=True, positive val indicates a flux vector towards the centre
    of the domain.

    val can be a vector with the same number of elements as the wall
    &#34;&#34;&#34;


    # (minX, maxX), (minY, maxY), (minZ, maxZ)

    if self.bc.has_key(str(wall)):
        self.bc[str(wall)][&#34;val&#34;]  = val
        self.bc[str(wall)][&#34;flux&#34;] = flux
        d = self.bc[str(wall)]

        mask = d[&#39;mask&#39;]

        if flux:
            self.dirichlet_mask[mask] = False                
            self.bc[str(wall)][&#34;val&#34;] /= -d[&#39;delta&#39;]
        else:
            self.dirichlet_mask[mask] = True

    else:
        raise ValueError(&#34;Wall should be one of &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, &#39;right&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="conduction.solver.conduction3d.Conduction3D.construct_matrix"><code class="name flex">
<span>def <span class="ident">construct_matrix</span></span>(<span>self, in_place=True, derivative=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the coefficient matrix
i.e. matrix A in Ax = b</p>
<p>We vectorise the 7-point stencil for fast matrix insertion.
An extra border of dummy values around the domain allows for automatic
Neumann (flux) boundary creation.
These are stomped on if there are any Dirichlet conditions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_matrix(self, in_place=True, derivative=False):
    &#34;&#34;&#34;
    Construct the coefficient matrix
    i.e. matrix A in Ax = b

    We vectorise the 7-point stencil for fast matrix insertion.
    An extra border of dummy values around the domain allows for automatic
    Neumann (flux) boundary creation.
    These are stomped on if there are any Dirichlet conditions.

    &#34;&#34;&#34;

    if in_place:
        mat = self.mat
    else:
        mat = PETSc.Mat().create(comm=comm)
        mat.setType(&#39;aij&#39;)
        mat.setSizes(self.sizes)
        mat.setLGMap(self.lgmap)
        mat.setFromOptions()
        mat.setPreallocationNNZ((7,comm.size-1))

    nodes = self.nodes
    nx, ny, nz = self.nx, self.ny, self.nz
    n = nx*ny*nz

    adx = 1.0/(2*self.dx**2)
    ady = 1.0/(2*self.dy**2)
    adz = 1.0/(2*self.dz**2)

    u = self.diffusivity.reshape(nz,ny,nx)

    k = np.zeros((nz+2, ny+2, nx+2))
    k[1:-1,1:-1,1:-1] = u

    index = np.empty((nz+2, ny+2, nx+2), dtype=PETSc.IntType)
    index.fill(-1)
    index[1:-1,1:-1,1:-1] = nodes.reshape(nz,ny,nx)

    rows = np.empty((7,n), dtype=PETSc.IntType)
    cols = np.empty((7,n), dtype=PETSc.IntType)
    vals = np.empty((7,n))

    dirichlet_mask = self.dirichlet_mask


    closure = [(0,-2), (1,-1), (1,-1), (2,0), (1,-1), (1,-1), (1,-1)]
    #         N    W    F    S    E    B    C
    delta = [ady, adx, adz, ady, adx, adz, 0.0]

    for i in range(7):
        rs, re = closure[i]
        cs, ce = closure[-1+i]
        ds, de = closure[-2+i]

        rows[i] = nodes
        cols[i] = index[ds:nz+de+2,rs:ny+re+2,cs:nx+ce+2].ravel()
        vals[i] = delta[i]*(k[ds:nz+de+2,rs:ny+re+2,cs:nx+ce+2] + u).ravel()


    # Dirichlet boundary conditions (duplicates are summed)
    cols[:,dirichlet_mask] = nodes[dirichlet_mask]
    vals[:,dirichlet_mask] = 0.0

    # zero off-grid coordinates
    vals[cols &lt; 0] = 0.0

    # centre point
    vals[-1] = 0.0
    if derivative:
        vals[-1][dirichlet_mask] = 0.
    else:
        vals[-1][dirichlet_mask] = -1.0


    row = rows.ravel()
    col = cols.ravel()
    val = vals.ravel()


    # mask off-grid entries and sum duplicates
    mask = col &gt; -1
    row, col, val = sum_duplicates(row[mask], col[mask], val[mask])


    # indptr, col, val = coo_tocsr(row, col, val)
    nnz = np.bincount(row)
    indptr = np.insert(np.cumsum(nnz),0,0)

    mat.assemblyBegin()
    mat.setValuesLocalCSR(indptr.astype(PETSc.IntType), col, val)
    mat.assemblyEnd()

    # set diagonal vector
    diag = mat.getRowSum()
    diag.scale(-1.0)
    mat.setDiagonal(diag)

    return mat</code></pre>
</details>
</dd>
<dt id="conduction.solver.conduction3d.Conduction3D.construct_rhs"><code class="name flex">
<span>def <span class="ident">construct_rhs</span></span>(<span>self, in_place=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the right-hand-side vector
i.e. vector b in Ax = b</p>
<p>Boundary conditions are grabbed from the dictionary and
summed to the rhs.
Be careful of duplicate entries on the corners!!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_rhs(self, in_place=True):
    &#34;&#34;&#34;
    Construct the right-hand-side vector
    i.e. vector b in Ax = b

    Boundary conditions are grabbed from the dictionary and
    summed to the rhs.
    Be careful of duplicate entries on the corners!!
    &#34;&#34;&#34;
    if in_place:
        rhs = self.rhs
    else:
        rhs = self.gvec.duplicate()
    
    vec = -1.0*self.heat_sources.copy()

    for wall in self.bc:
        val  = self.bc[wall][&#39;val&#39;]
        flux = self.bc[wall][&#39;flux&#39;]
        mask = self.bc[wall][&#39;mask&#39;]
        if flux:
            vec[mask] += val
        else:
            vec[mask] = val

    self.lvec.setArray(vec)
    self.dm.localToGlobal(self.lvec, rhs)

    return rhs</code></pre>
</details>
</dd>
<dt id="conduction.solver.conduction3d.Conduction3D.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, solver='gmres')</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the matrix A and vector b in Ax = b
and solve for x</p>
<p>GMRES method is default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, solver=&#39;gmres&#39;):
    &#34;&#34;&#34;
    Construct the matrix A and vector b in Ax = b
    and solve for x

    GMRES method is default
    &#34;&#34;&#34;
    matrix = self.construct_matrix()
    rhs = self.construct_rhs()
    res = self.dm.createGlobalVector()

    ksp = PETSc.KSP().create(comm=comm)
    ksp.setType(solver)
    ksp.setOperators(matrix)
    ksp.setFromOptions()
    ksp.setTolerances(1e-10, 1e-50)
    ksp.solve(rhs, res)
    return res.array</code></pre>
</details>
</dd>
<dt id="conduction.solver.conduction3d.Conduction3D.update_properties"><code class="name flex">
<span>def <span class="ident">update_properties</span></span>(<span>self, diffusivity, heat_sources)</span>
</code></dt>
<dd>
<div class="desc"><p>Update diffusivity and heat sources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_properties(self, diffusivity, heat_sources):
    &#34;&#34;&#34;
    Update diffusivity and heat sources
    &#34;&#34;&#34;

    self.diffusivity = np.asarray(diffusivity)
    self.heat_sources = np.asarray(heat_sources)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="conduction.solver" href="index.html">conduction.solver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="conduction.solver.conduction3d.coo_tocsr" href="#conduction.solver.conduction3d.coo_tocsr">coo_tocsr</a></code></li>
<li><code><a title="conduction.solver.conduction3d.csr_tocoo" href="#conduction.solver.conduction3d.csr_tocoo">csr_tocoo</a></code></li>
<li><code><a title="conduction.solver.conduction3d.sum_duplicates" href="#conduction.solver.conduction3d.sum_duplicates">sum_duplicates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="conduction.solver.conduction3d.Conduction3D" href="#conduction.solver.conduction3d.Conduction3D">Conduction3D</a></code></h4>
<ul class="">
<li><code><a title="conduction.solver.conduction3d.Conduction3D.boundary_condition" href="#conduction.solver.conduction3d.Conduction3D.boundary_condition">boundary_condition</a></code></li>
<li><code><a title="conduction.solver.conduction3d.Conduction3D.construct_matrix" href="#conduction.solver.conduction3d.Conduction3D.construct_matrix">construct_matrix</a></code></li>
<li><code><a title="conduction.solver.conduction3d.Conduction3D.construct_rhs" href="#conduction.solver.conduction3d.Conduction3D.construct_rhs">construct_rhs</a></code></li>
<li><code><a title="conduction.solver.conduction3d.Conduction3D.solve" href="#conduction.solver.conduction3d.Conduction3D.solve">solve</a></code></li>
<li><code><a title="conduction.solver.conduction3d.Conduction3D.update_properties" href="#conduction.solver.conduction3d.Conduction3D.update_properties">update_properties</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>conduction.solver.conductionNd_serial API documentation</title>
<meta name="description" content="Copyright 2017 Ben Mather â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>conduction.solver.conductionNd_serial</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2017 Ben Mather</p>
<p>This file is part of Conduction <a href="https://git.dias.ie/itherc/conduction/">https://git.dias.ie/itherc/conduction/</a></p>
<p>Conduction is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Conduction is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with Conduction.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2017 Ben Mather

This file is part of Conduction &lt;https://git.dias.ie/itherc/conduction/&gt;

Conduction is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

Conduction is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Conduction.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

try: range = xrange
except: pass

import numpy as np
from scipy import sparse
from scipy.sparse import linalg

class ConductionND(object):
    &#34;&#34;&#34;
    Implicit ND steady-state heat equation solver over a structured grid
    (Serial version)
    &#34;&#34;&#34;

    def __init__(self, minCoord, maxCoord, res, **kwargs):

        dim = len(res)
        extent = np.zeros(dim*2)

        index = 0
        sizes = 1

        bbox  = list(range(dim))
        n = np.zeros(dim, dtype=np.int32)

        width = kwargs.pop(&#39;stencil_width&#39;, 1)

        for i in range(0, dim):
            extent[index]   = minCoord[i]
            extent[index+1] = maxCoord[i]
            index += 2
            sizes *= res[i]
            bbox[i] = (minCoord[i], maxCoord[i])
            n[i] = res[i]

        # Setup matrix sizes
        self.sizes = (sizes, sizes)
        self.dim = dim
        self.extent = extent
        self.bbox = bbox

        nn = sizes
        self.n = n[::-1]
        self.nn = nn
        self.npoints = nn

        # stencil size
        self.width = width
        self.stencil_width = 2*dim*width + 1

        # local numbering
        self.nodes = np.arange(0, nn, dtype=np.int32)

        # closure depends on dim
        if dim == 1:
            closure = [(0,-2),(2,0),(1,-1)]
        elif dim == 2:
            closure = [(0,-2), (1,-1), (2,0), (1,-1), (1,-1)]
        elif dim == 3:
            closure = [(0,-2), (1,-1), (1,-1), (2,0), (1,-1), (1,-1), (1,-1)]
        self.closure = self._create_closure_object(closure)


        # interior slices
        self.interior_slice = [None]*dim
        for i in range(0, dim):
            self.interior_slice[i] = slice(1, -1)


        self._initialise_mesh_variables()
        self._initialise_boundary_dictionary()
        self._initialise_COO_vectors()

        # thermal properties
        self.diffusivity  = np.zeros(nn)
        self.heat_sources = np.zeros(nn)
        self.temperature  = np.zeros(nn)

        # right hand side vector
        self.rhs = np.zeros(nn)


    def _initialise_COO_vectors(self):

        nn = self.nn
        n = self.n

        index = np.empty(n + 2, dtype=np.int32)
        index.fill(-1)
        index[self.interior_slice] = self.nodes.reshape(n)
        self.index = index

        self.rows = np.empty((self.stencil_width, nn), dtype=np.int32)
        self.cols = np.empty((self.stencil_width, nn), dtype=np.int32)
        self.vals = np.empty((self.stencil_width, nn))



    def _initialise_mesh_variables(self):

        dim = self.dim
        bbox = self.bbox
        n = self.n[::-1]

        extent = np.zeros(dim*2)

        index = 0
        for bs, be in bbox:
            extent[index]   = bs
            extent[index+1] = be
            index += 2

        self.extent = extent

        # local coordinates
        grid_coords = [None]*dim
        for i in range(0, dim):
            minI, maxI = bbox[i]
            size = n[i]
            grid_coords[i] = np.linspace(minI, maxI, size)


        coord_arrays = np.meshgrid(*grid_coords[::-1], indexing=&#39;ij&#39;)
        coords = np.empty((self.nn, dim))
        for i in range(0, dim):
            coords[:,i] = coord_arrays[::-1][i].ravel()

        self.grid_coords = grid_coords
        self.coords = coords


    def _initialise_boundary_dictionary(self):

        coords = self.coords
        grid_coords = self.grid_coords
        dim = self.dim

        minCoords = coords.min(axis=0)
        maxCoords = coords.max(axis=0)

        bbox = self.bbox
        n = self.n[::-1]

        # Setup boundary dictionary
        bc = dict()

        wall = [(&#34;minX&#34;, &#34;maxX&#34;), (&#34;minY&#34;, &#34;maxY&#34;), (&#34;minZ&#34;, &#34;maxZ&#34;)]

        for i in range(0, dim):
            w0, w1 = wall[i]
            c0, c1 = bbox[i]
            m0, m1 = self.coords[:,i] == c0, self.coords[:,i] == c1
            d0 = d1 = (c1 - c0)/(n[i] - 1)

            bc[w0] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d0, &#34;flux&#34;: True, &#34;mask&#34;: m0}
            bc[w1] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d1, &#34;flux&#34;: True, &#34;mask&#34;: m1}

        self.bc = bc
        self.dirichlet_mask = np.zeros(self.nn, dtype=bool)


    def _create_closure_object(self, closure):

        n = self.n
        obj = [[0] * self.dim for i in range(self.stencil_width)]

        for i in range(0, self.stencil_width):
            # construct slicing object
            for j in range(0, self.dim):
                start, end = closure[i-j]
                obj[i][j] = slice(start, n[j]+end+2)

        return obj


    def update_properties(self, diffusivity, heat_sources):
        &#34;&#34;&#34;
        Update diffusivity and heat sources
        &#34;&#34;&#34;
        self.diffusivity = diffusivity
        self.heat_sources = heat_sources


    def boundary_condition(self, wall, val, flux=True):
        &#34;&#34;&#34;
        Set the boundary conditions on each wall of the domain.
        By default each wall is a Neumann (flux) condition.
        If flux=True, positive val indicates a flux vector towards the centre
        of the domain.

        val can be a vector with the same number of elements as the wall
        &#34;&#34;&#34;
        wall = str(wall)

        if wall in self.bc:
            self.bc[wall][&#34;val&#34;]  = np.array(val, copy=True)
            self.bc[wall][&#34;flux&#34;] = flux
            d = self.bc[wall]

            mask = d[&#39;mask&#39;]

            if flux:
                self.dirichlet_mask[mask] = False
                self.bc[wall][&#34;val&#34;] /= -d[&#39;delta&#39;]
            else:
                self.dirichlet_mask[mask] = True

        else:
            raise ValueError(&#34;Wall should be one of {}&#34;.format(self.bc.keys()))



    def construct_matrix(self, derivative=False):
        &#34;&#34;&#34;
        Construct the coefficient matrix
        i.e. matrix A in Ax = b

        We vectorise the 7-point stencil for fast matrix insertion.
        An extra border of dummy values around the domain allows for automatic
        Neumann (flux) boundary creation.
        These are stomped on if there are any Dirichlet conditions.

        &#34;&#34;&#34;

        nodes = self.nodes
        nn = self.nn
        n = self.n
        dim = self.dim

        index = self.index

        rows = self.rows
        cols = self.cols
        vals = self.vals

        dirichlet_mask = self.dirichlet_mask

        u = self.diffusivity.reshape(n)

        k = np.zeros(n + 2)
        k[self.interior_slice] = u

        for i in range(0, self.stencil_width):
            obj = self.closure[i]

            rows[i] = nodes
            cols[i] = index[obj].ravel()

            distance = np.linalg.norm(self.coords[cols[i]] - self.coords, axis=1)
            distance[distance==0] = 1e-12 # protect against dividing by zero
            delta = 1.0/(2.0*distance**2)

            vals[i] = delta*(k[obj] + u).ravel()


        # Dirichlet boundary conditions (duplicates are summed)
        cols[:,dirichlet_mask] = nodes[dirichlet_mask]
        vals[:,dirichlet_mask] = 0.0

        # zero off-grid coordinates
        vals[cols &lt; 0] = 0.0

        # centre point
        vals[-1] = 0.0
        if derivative:
            vals[-1][dirichlet_mask] = 0.
        else:
            vals[-1][dirichlet_mask] = -1.0


        row = rows.ravel()
        col = cols.ravel()
        val = vals.ravel()


        # mask off-grid entries and sum duplicates
        mask = col &gt;= 0
        row = row[mask]
        col = col[mask]
        val = val[mask]

        mat = sparse.coo_matrix((val, (row, col)), shape=self.sizes).tocsr()
        mat.sum_duplicates()
        diag = np.ravel(mat.sum(axis=1))
        diag *= -1
        mat.setdiag(diag)

        return mat


    def construct_rhs(self):
        &#34;&#34;&#34;
        Construct the right-hand-side vector
        i.e. vector b in Ax = b

        Boundary conditions are grabbed from the dictionary and
        summed to the rhs.
        Be careful of duplicate entries on the corners!!
        &#34;&#34;&#34;
        
        rhs = -1.0*self.heat_sources

        for wall in self.bc:
            val  = self.bc[wall][&#39;val&#39;]
            flux = self.bc[wall][&#39;flux&#39;]
            mask = self.bc[wall][&#39;mask&#39;]
            if flux:
                rhs[mask] += val
            else:
                rhs[mask] = val

        return rhs


    def solve(self, matrix=None, rhs=None):
        &#34;&#34;&#34;
        Construct the matrix A and vector b in Ax = b
        and solve for x

        GMRES method is default
        &#34;&#34;&#34;
        if matrix is None:
            matrix = self.construct_matrix()
        if rhs is None:
            rhs = self.construct_rhs()
        res = self.temperature

        T = linalg.spsolve(matrix, rhs)
        self.temperature = T

        return T


    def gradient(self, vector, **kwargs):

        return np.gradient(vector.reshape(self.n), *self.grid_coords[::-1], **kwargs)


    def heatflux(self):

        T = self.temperature
        k = self.diffusivity * -1
        divT = self.gradient(T)
        for i in range(0, self.dim):
            div = k*divT[i].ravel()
            divT[i] = div

        return divT


    def isosurface(self, vector, isoval, axis=0, interp=&#39;nearest&#39;):
        &#34;&#34;&#34;
        Calculate an isosurface along a given axis
        (So far this is only working for axis=0)

        Parameters
        ----------
         vector : array, the same size as the mesh (n,)
         isoval : float, isosurface value
         axis   : int, axis to generate the isosurface
         interp : str, method can be either
            &#39;nearest&#39; - nearest neighbour interpolation
            &#39;linear&#39;  - linear interpolation
        
        Returns
        -------
         z_interp : isosurface the same size as the specified axis
        &#34;&#34;&#34;
        Vcube = vector.reshape(self.n)
        Zcube = self.coords[:,::-1][:,axis].reshape(self.n)
        sort_idx = ((Vcube - isoval)**2).argsort(axis=axis)    
        i0 = sort_idx[0]
        # z0 = Zcube.take(i0)
        
        obj = []
        for d in range(0, self.dim):
            obj.append( slice(0, self.n[d]) )
        obj.pop(axis)
        
        idx = list(np.mgrid[obj])
        idx.insert(axis, i0)
        z0 = Zcube[idx]

        if interp == &#39;linear&#39;:
            v0 = Vcube[idx]
            
            # identify next nearest node
            i1 = sort_idx[1]
            idx[axis] = i1
            z1 = Zcube[idx]
            v1 = Vcube[idx]

            vmin = np.minimum(v0, v1)
            vmax = np.maximum(v0, v1)
            ratio = np.vstack([np.ones_like(vmax)*isoval, vmin, vmax])
            ratio -= ratio.min(axis=0)
            ratio /= ratio.max(axis=0)
            z_interp = ratio[0]*z1 + (1.0 - ratio[0])*z0
            return z_interp
        elif interp == &#39;nearest&#39;:
            return z0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="conduction.solver.conductionNd_serial.ConductionND"><code class="flex name class">
<span>class <span class="ident">ConductionND</span></span>
<span>(</span><span>minCoord, maxCoord, res, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implicit ND steady-state heat equation solver over a structured grid
(Serial version)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConductionND(object):
    &#34;&#34;&#34;
    Implicit ND steady-state heat equation solver over a structured grid
    (Serial version)
    &#34;&#34;&#34;

    def __init__(self, minCoord, maxCoord, res, **kwargs):

        dim = len(res)
        extent = np.zeros(dim*2)

        index = 0
        sizes = 1

        bbox  = list(range(dim))
        n = np.zeros(dim, dtype=np.int32)

        width = kwargs.pop(&#39;stencil_width&#39;, 1)

        for i in range(0, dim):
            extent[index]   = minCoord[i]
            extent[index+1] = maxCoord[i]
            index += 2
            sizes *= res[i]
            bbox[i] = (minCoord[i], maxCoord[i])
            n[i] = res[i]

        # Setup matrix sizes
        self.sizes = (sizes, sizes)
        self.dim = dim
        self.extent = extent
        self.bbox = bbox

        nn = sizes
        self.n = n[::-1]
        self.nn = nn
        self.npoints = nn

        # stencil size
        self.width = width
        self.stencil_width = 2*dim*width + 1

        # local numbering
        self.nodes = np.arange(0, nn, dtype=np.int32)

        # closure depends on dim
        if dim == 1:
            closure = [(0,-2),(2,0),(1,-1)]
        elif dim == 2:
            closure = [(0,-2), (1,-1), (2,0), (1,-1), (1,-1)]
        elif dim == 3:
            closure = [(0,-2), (1,-1), (1,-1), (2,0), (1,-1), (1,-1), (1,-1)]
        self.closure = self._create_closure_object(closure)


        # interior slices
        self.interior_slice = [None]*dim
        for i in range(0, dim):
            self.interior_slice[i] = slice(1, -1)


        self._initialise_mesh_variables()
        self._initialise_boundary_dictionary()
        self._initialise_COO_vectors()

        # thermal properties
        self.diffusivity  = np.zeros(nn)
        self.heat_sources = np.zeros(nn)
        self.temperature  = np.zeros(nn)

        # right hand side vector
        self.rhs = np.zeros(nn)


    def _initialise_COO_vectors(self):

        nn = self.nn
        n = self.n

        index = np.empty(n + 2, dtype=np.int32)
        index.fill(-1)
        index[self.interior_slice] = self.nodes.reshape(n)
        self.index = index

        self.rows = np.empty((self.stencil_width, nn), dtype=np.int32)
        self.cols = np.empty((self.stencil_width, nn), dtype=np.int32)
        self.vals = np.empty((self.stencil_width, nn))



    def _initialise_mesh_variables(self):

        dim = self.dim
        bbox = self.bbox
        n = self.n[::-1]

        extent = np.zeros(dim*2)

        index = 0
        for bs, be in bbox:
            extent[index]   = bs
            extent[index+1] = be
            index += 2

        self.extent = extent

        # local coordinates
        grid_coords = [None]*dim
        for i in range(0, dim):
            minI, maxI = bbox[i]
            size = n[i]
            grid_coords[i] = np.linspace(minI, maxI, size)


        coord_arrays = np.meshgrid(*grid_coords[::-1], indexing=&#39;ij&#39;)
        coords = np.empty((self.nn, dim))
        for i in range(0, dim):
            coords[:,i] = coord_arrays[::-1][i].ravel()

        self.grid_coords = grid_coords
        self.coords = coords


    def _initialise_boundary_dictionary(self):

        coords = self.coords
        grid_coords = self.grid_coords
        dim = self.dim

        minCoords = coords.min(axis=0)
        maxCoords = coords.max(axis=0)

        bbox = self.bbox
        n = self.n[::-1]

        # Setup boundary dictionary
        bc = dict()

        wall = [(&#34;minX&#34;, &#34;maxX&#34;), (&#34;minY&#34;, &#34;maxY&#34;), (&#34;minZ&#34;, &#34;maxZ&#34;)]

        for i in range(0, dim):
            w0, w1 = wall[i]
            c0, c1 = bbox[i]
            m0, m1 = self.coords[:,i] == c0, self.coords[:,i] == c1
            d0 = d1 = (c1 - c0)/(n[i] - 1)

            bc[w0] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d0, &#34;flux&#34;: True, &#34;mask&#34;: m0}
            bc[w1] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d1, &#34;flux&#34;: True, &#34;mask&#34;: m1}

        self.bc = bc
        self.dirichlet_mask = np.zeros(self.nn, dtype=bool)


    def _create_closure_object(self, closure):

        n = self.n
        obj = [[0] * self.dim for i in range(self.stencil_width)]

        for i in range(0, self.stencil_width):
            # construct slicing object
            for j in range(0, self.dim):
                start, end = closure[i-j]
                obj[i][j] = slice(start, n[j]+end+2)

        return obj


    def update_properties(self, diffusivity, heat_sources):
        &#34;&#34;&#34;
        Update diffusivity and heat sources
        &#34;&#34;&#34;
        self.diffusivity = diffusivity
        self.heat_sources = heat_sources


    def boundary_condition(self, wall, val, flux=True):
        &#34;&#34;&#34;
        Set the boundary conditions on each wall of the domain.
        By default each wall is a Neumann (flux) condition.
        If flux=True, positive val indicates a flux vector towards the centre
        of the domain.

        val can be a vector with the same number of elements as the wall
        &#34;&#34;&#34;
        wall = str(wall)

        if wall in self.bc:
            self.bc[wall][&#34;val&#34;]  = np.array(val, copy=True)
            self.bc[wall][&#34;flux&#34;] = flux
            d = self.bc[wall]

            mask = d[&#39;mask&#39;]

            if flux:
                self.dirichlet_mask[mask] = False
                self.bc[wall][&#34;val&#34;] /= -d[&#39;delta&#39;]
            else:
                self.dirichlet_mask[mask] = True

        else:
            raise ValueError(&#34;Wall should be one of {}&#34;.format(self.bc.keys()))



    def construct_matrix(self, derivative=False):
        &#34;&#34;&#34;
        Construct the coefficient matrix
        i.e. matrix A in Ax = b

        We vectorise the 7-point stencil for fast matrix insertion.
        An extra border of dummy values around the domain allows for automatic
        Neumann (flux) boundary creation.
        These are stomped on if there are any Dirichlet conditions.

        &#34;&#34;&#34;

        nodes = self.nodes
        nn = self.nn
        n = self.n
        dim = self.dim

        index = self.index

        rows = self.rows
        cols = self.cols
        vals = self.vals

        dirichlet_mask = self.dirichlet_mask

        u = self.diffusivity.reshape(n)

        k = np.zeros(n + 2)
        k[self.interior_slice] = u

        for i in range(0, self.stencil_width):
            obj = self.closure[i]

            rows[i] = nodes
            cols[i] = index[obj].ravel()

            distance = np.linalg.norm(self.coords[cols[i]] - self.coords, axis=1)
            distance[distance==0] = 1e-12 # protect against dividing by zero
            delta = 1.0/(2.0*distance**2)

            vals[i] = delta*(k[obj] + u).ravel()


        # Dirichlet boundary conditions (duplicates are summed)
        cols[:,dirichlet_mask] = nodes[dirichlet_mask]
        vals[:,dirichlet_mask] = 0.0

        # zero off-grid coordinates
        vals[cols &lt; 0] = 0.0

        # centre point
        vals[-1] = 0.0
        if derivative:
            vals[-1][dirichlet_mask] = 0.
        else:
            vals[-1][dirichlet_mask] = -1.0


        row = rows.ravel()
        col = cols.ravel()
        val = vals.ravel()


        # mask off-grid entries and sum duplicates
        mask = col &gt;= 0
        row = row[mask]
        col = col[mask]
        val = val[mask]

        mat = sparse.coo_matrix((val, (row, col)), shape=self.sizes).tocsr()
        mat.sum_duplicates()
        diag = np.ravel(mat.sum(axis=1))
        diag *= -1
        mat.setdiag(diag)

        return mat


    def construct_rhs(self):
        &#34;&#34;&#34;
        Construct the right-hand-side vector
        i.e. vector b in Ax = b

        Boundary conditions are grabbed from the dictionary and
        summed to the rhs.
        Be careful of duplicate entries on the corners!!
        &#34;&#34;&#34;
        
        rhs = -1.0*self.heat_sources

        for wall in self.bc:
            val  = self.bc[wall][&#39;val&#39;]
            flux = self.bc[wall][&#39;flux&#39;]
            mask = self.bc[wall][&#39;mask&#39;]
            if flux:
                rhs[mask] += val
            else:
                rhs[mask] = val

        return rhs


    def solve(self, matrix=None, rhs=None):
        &#34;&#34;&#34;
        Construct the matrix A and vector b in Ax = b
        and solve for x

        GMRES method is default
        &#34;&#34;&#34;
        if matrix is None:
            matrix = self.construct_matrix()
        if rhs is None:
            rhs = self.construct_rhs()
        res = self.temperature

        T = linalg.spsolve(matrix, rhs)
        self.temperature = T

        return T


    def gradient(self, vector, **kwargs):

        return np.gradient(vector.reshape(self.n), *self.grid_coords[::-1], **kwargs)


    def heatflux(self):

        T = self.temperature
        k = self.diffusivity * -1
        divT = self.gradient(T)
        for i in range(0, self.dim):
            div = k*divT[i].ravel()
            divT[i] = div

        return divT


    def isosurface(self, vector, isoval, axis=0, interp=&#39;nearest&#39;):
        &#34;&#34;&#34;
        Calculate an isosurface along a given axis
        (So far this is only working for axis=0)

        Parameters
        ----------
         vector : array, the same size as the mesh (n,)
         isoval : float, isosurface value
         axis   : int, axis to generate the isosurface
         interp : str, method can be either
            &#39;nearest&#39; - nearest neighbour interpolation
            &#39;linear&#39;  - linear interpolation
        
        Returns
        -------
         z_interp : isosurface the same size as the specified axis
        &#34;&#34;&#34;
        Vcube = vector.reshape(self.n)
        Zcube = self.coords[:,::-1][:,axis].reshape(self.n)
        sort_idx = ((Vcube - isoval)**2).argsort(axis=axis)    
        i0 = sort_idx[0]
        # z0 = Zcube.take(i0)
        
        obj = []
        for d in range(0, self.dim):
            obj.append( slice(0, self.n[d]) )
        obj.pop(axis)
        
        idx = list(np.mgrid[obj])
        idx.insert(axis, i0)
        z0 = Zcube[idx]

        if interp == &#39;linear&#39;:
            v0 = Vcube[idx]
            
            # identify next nearest node
            i1 = sort_idx[1]
            idx[axis] = i1
            z1 = Zcube[idx]
            v1 = Vcube[idx]

            vmin = np.minimum(v0, v1)
            vmax = np.maximum(v0, v1)
            ratio = np.vstack([np.ones_like(vmax)*isoval, vmin, vmax])
            ratio -= ratio.min(axis=0)
            ratio /= ratio.max(axis=0)
            z_interp = ratio[0]*z1 + (1.0 - ratio[0])*z0
            return z_interp
        elif interp == &#39;nearest&#39;:
            return z0</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="conduction.solver.diffusionNd_serial.DiffusionND" href="diffusionNd_serial.html#conduction.solver.diffusionNd_serial.DiffusionND">DiffusionND</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="conduction.solver.conductionNd_serial.ConductionND.boundary_condition"><code class="name flex">
<span>def <span class="ident">boundary_condition</span></span>(<span>self, wall, val, flux=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the boundary conditions on each wall of the domain.
By default each wall is a Neumann (flux) condition.
If flux=True, positive val indicates a flux vector towards the centre
of the domain.</p>
<p>val can be a vector with the same number of elements as the wall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundary_condition(self, wall, val, flux=True):
    &#34;&#34;&#34;
    Set the boundary conditions on each wall of the domain.
    By default each wall is a Neumann (flux) condition.
    If flux=True, positive val indicates a flux vector towards the centre
    of the domain.

    val can be a vector with the same number of elements as the wall
    &#34;&#34;&#34;
    wall = str(wall)

    if wall in self.bc:
        self.bc[wall][&#34;val&#34;]  = np.array(val, copy=True)
        self.bc[wall][&#34;flux&#34;] = flux
        d = self.bc[wall]

        mask = d[&#39;mask&#39;]

        if flux:
            self.dirichlet_mask[mask] = False
            self.bc[wall][&#34;val&#34;] /= -d[&#39;delta&#39;]
        else:
            self.dirichlet_mask[mask] = True

    else:
        raise ValueError(&#34;Wall should be one of {}&#34;.format(self.bc.keys()))</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.construct_matrix"><code class="name flex">
<span>def <span class="ident">construct_matrix</span></span>(<span>self, derivative=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the coefficient matrix
i.e. matrix A in Ax = b</p>
<p>We vectorise the 7-point stencil for fast matrix insertion.
An extra border of dummy values around the domain allows for automatic
Neumann (flux) boundary creation.
These are stomped on if there are any Dirichlet conditions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_matrix(self, derivative=False):
    &#34;&#34;&#34;
    Construct the coefficient matrix
    i.e. matrix A in Ax = b

    We vectorise the 7-point stencil for fast matrix insertion.
    An extra border of dummy values around the domain allows for automatic
    Neumann (flux) boundary creation.
    These are stomped on if there are any Dirichlet conditions.

    &#34;&#34;&#34;

    nodes = self.nodes
    nn = self.nn
    n = self.n
    dim = self.dim

    index = self.index

    rows = self.rows
    cols = self.cols
    vals = self.vals

    dirichlet_mask = self.dirichlet_mask

    u = self.diffusivity.reshape(n)

    k = np.zeros(n + 2)
    k[self.interior_slice] = u

    for i in range(0, self.stencil_width):
        obj = self.closure[i]

        rows[i] = nodes
        cols[i] = index[obj].ravel()

        distance = np.linalg.norm(self.coords[cols[i]] - self.coords, axis=1)
        distance[distance==0] = 1e-12 # protect against dividing by zero
        delta = 1.0/(2.0*distance**2)

        vals[i] = delta*(k[obj] + u).ravel()


    # Dirichlet boundary conditions (duplicates are summed)
    cols[:,dirichlet_mask] = nodes[dirichlet_mask]
    vals[:,dirichlet_mask] = 0.0

    # zero off-grid coordinates
    vals[cols &lt; 0] = 0.0

    # centre point
    vals[-1] = 0.0
    if derivative:
        vals[-1][dirichlet_mask] = 0.
    else:
        vals[-1][dirichlet_mask] = -1.0


    row = rows.ravel()
    col = cols.ravel()
    val = vals.ravel()


    # mask off-grid entries and sum duplicates
    mask = col &gt;= 0
    row = row[mask]
    col = col[mask]
    val = val[mask]

    mat = sparse.coo_matrix((val, (row, col)), shape=self.sizes).tocsr()
    mat.sum_duplicates()
    diag = np.ravel(mat.sum(axis=1))
    diag *= -1
    mat.setdiag(diag)

    return mat</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.construct_rhs"><code class="name flex">
<span>def <span class="ident">construct_rhs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the right-hand-side vector
i.e. vector b in Ax = b</p>
<p>Boundary conditions are grabbed from the dictionary and
summed to the rhs.
Be careful of duplicate entries on the corners!!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_rhs(self):
    &#34;&#34;&#34;
    Construct the right-hand-side vector
    i.e. vector b in Ax = b

    Boundary conditions are grabbed from the dictionary and
    summed to the rhs.
    Be careful of duplicate entries on the corners!!
    &#34;&#34;&#34;
    
    rhs = -1.0*self.heat_sources

    for wall in self.bc:
        val  = self.bc[wall][&#39;val&#39;]
        flux = self.bc[wall][&#39;flux&#39;]
        mask = self.bc[wall][&#39;mask&#39;]
        if flux:
            rhs[mask] += val
        else:
            rhs[mask] = val

    return rhs</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, vector, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient(self, vector, **kwargs):

    return np.gradient(vector.reshape(self.n), *self.grid_coords[::-1], **kwargs)</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.heatflux"><code class="name flex">
<span>def <span class="ident">heatflux</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heatflux(self):

    T = self.temperature
    k = self.diffusivity * -1
    divT = self.gradient(T)
    for i in range(0, self.dim):
        div = k*divT[i].ravel()
        divT[i] = div

    return divT</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.isosurface"><code class="name flex">
<span>def <span class="ident">isosurface</span></span>(<span>self, vector, isoval, axis=0, interp='nearest')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate an isosurface along a given axis
(So far this is only working for axis=0)</p>
<h2 id="parameters">Parameters</h2>
<p>vector : array, the same size as the mesh (n,)
isoval : float, isosurface value
axis
: int, axis to generate the isosurface
interp : str, method can be either
'nearest' - nearest neighbour interpolation
'linear'
- linear interpolation</p>
<h2 id="returns">Returns</h2>
<p>z_interp : isosurface the same size as the specified axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isosurface(self, vector, isoval, axis=0, interp=&#39;nearest&#39;):
    &#34;&#34;&#34;
    Calculate an isosurface along a given axis
    (So far this is only working for axis=0)

    Parameters
    ----------
     vector : array, the same size as the mesh (n,)
     isoval : float, isosurface value
     axis   : int, axis to generate the isosurface
     interp : str, method can be either
        &#39;nearest&#39; - nearest neighbour interpolation
        &#39;linear&#39;  - linear interpolation
    
    Returns
    -------
     z_interp : isosurface the same size as the specified axis
    &#34;&#34;&#34;
    Vcube = vector.reshape(self.n)
    Zcube = self.coords[:,::-1][:,axis].reshape(self.n)
    sort_idx = ((Vcube - isoval)**2).argsort(axis=axis)    
    i0 = sort_idx[0]
    # z0 = Zcube.take(i0)
    
    obj = []
    for d in range(0, self.dim):
        obj.append( slice(0, self.n[d]) )
    obj.pop(axis)
    
    idx = list(np.mgrid[obj])
    idx.insert(axis, i0)
    z0 = Zcube[idx]

    if interp == &#39;linear&#39;:
        v0 = Vcube[idx]
        
        # identify next nearest node
        i1 = sort_idx[1]
        idx[axis] = i1
        z1 = Zcube[idx]
        v1 = Vcube[idx]

        vmin = np.minimum(v0, v1)
        vmax = np.maximum(v0, v1)
        ratio = np.vstack([np.ones_like(vmax)*isoval, vmin, vmax])
        ratio -= ratio.min(axis=0)
        ratio /= ratio.max(axis=0)
        z_interp = ratio[0]*z1 + (1.0 - ratio[0])*z0
        return z_interp
    elif interp == &#39;nearest&#39;:
        return z0</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, matrix=None, rhs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the matrix A and vector b in Ax = b
and solve for x</p>
<p>GMRES method is default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, matrix=None, rhs=None):
    &#34;&#34;&#34;
    Construct the matrix A and vector b in Ax = b
    and solve for x

    GMRES method is default
    &#34;&#34;&#34;
    if matrix is None:
        matrix = self.construct_matrix()
    if rhs is None:
        rhs = self.construct_rhs()
    res = self.temperature

    T = linalg.spsolve(matrix, rhs)
    self.temperature = T

    return T</code></pre>
</details>
</dd>
<dt id="conduction.solver.conductionNd_serial.ConductionND.update_properties"><code class="name flex">
<span>def <span class="ident">update_properties</span></span>(<span>self, diffusivity, heat_sources)</span>
</code></dt>
<dd>
<div class="desc"><p>Update diffusivity and heat sources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_properties(self, diffusivity, heat_sources):
    &#34;&#34;&#34;
    Update diffusivity and heat sources
    &#34;&#34;&#34;
    self.diffusivity = diffusivity
    self.heat_sources = heat_sources</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="conduction.solver" href="index.html">conduction.solver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="conduction.solver.conductionNd_serial.ConductionND" href="#conduction.solver.conductionNd_serial.ConductionND">ConductionND</a></code></h4>
<ul class="two-column">
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.boundary_condition" href="#conduction.solver.conductionNd_serial.ConductionND.boundary_condition">boundary_condition</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.construct_matrix" href="#conduction.solver.conductionNd_serial.ConductionND.construct_matrix">construct_matrix</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.construct_rhs" href="#conduction.solver.conductionNd_serial.ConductionND.construct_rhs">construct_rhs</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.gradient" href="#conduction.solver.conductionNd_serial.ConductionND.gradient">gradient</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.heatflux" href="#conduction.solver.conductionNd_serial.ConductionND.heatflux">heatflux</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.isosurface" href="#conduction.solver.conductionNd_serial.ConductionND.isosurface">isosurface</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.solve" href="#conduction.solver.conductionNd_serial.ConductionND.solve">solve</a></code></li>
<li><code><a title="conduction.solver.conductionNd_serial.ConductionND.update_properties" href="#conduction.solver.conductionNd_serial.ConductionND.update_properties">update_properties</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
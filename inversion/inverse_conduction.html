<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>conduction.inversion.inverse_conduction API documentation</title>
<meta name="description" content="Copyright 2017 Ben Mather â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>conduction.inversion.inverse_conduction</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2017 Ben Mather</p>
<p>This file is part of Conduction <a href="https://git.dias.ie/itherc/conduction/">https://git.dias.ie/itherc/conduction/</a></p>
<p>Conduction is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Conduction is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with Conduction.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2017 Ben Mather

This file is part of Conduction &lt;https://git.dias.ie/itherc/conduction/&gt;

Conduction is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

Conduction is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Conduction.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

try: range = xrange
except: pass

import numpy as np
from ..interpolation import RegularGridInterpolator
from mpi4py import MPI
from petsc4py import PETSc
comm = MPI.COMM_WORLD

from ..mesh import MeshVariable

class Inversion(object):

    def __init__(self, lithology, mesh):
        self.mesh = mesh
        self.lithology = np.array(lithology).ravel()

        # communicate lithology index
        lithology_index = np.unique(lithology)
        lith_min, lith_max = np.array(lithology_index.min(), dtype=float), np.array(lithology_index.max(), dtype=float)
        all_lith_min, all_lith_max = np.array(0.0), np.array(0.0)
        comm.Allreduce([lith_min, MPI.DOUBLE], [all_lith_min, MPI.DOUBLE], op=MPI.MIN)
        comm.Allreduce([lith_max, MPI.DOUBLE], [all_lith_max, MPI.DOUBLE], op=MPI.MAX)

        # self.lithology_index = np.unique(lithology)
        # self.lithology_index.sort()
        self.lithology_index = np.arange(int(all_lith_min), int(all_lith_max)+1)

        self.lithology_mask = np.zeros((len(self.lithology_index), mesh.nn), dtype=bool)

        for i, index in enumerate(self.lithology_index):
            self.lithology_mask[i] = self.lithology == index


        minX, minY, minZ = mesh.coords.min(axis=0)
        maxX, maxY, maxZ = mesh.coords.max(axis=0)


        Xcoords = np.unique(mesh.coords[:,0])
        Ycoords = np.unique(mesh.coords[:,1])
        Zcoords = np.unique(mesh.coords[:,2])

        nx, ny, nz = Xcoords.size, Ycoords.size, Zcoords.size

        self.dx = (maxX - minX)/nx
        self.dy = (maxY - minY)/ny
        self.dz = (maxZ - minZ)/nz

        self.nx = nx
        self.ny = ny
        self.nz = nz


        self.interp = RegularGridInterpolator(mesh.grid_coords[::-1],
                                              np.zeros(mesh.n),
                                              bounds_error=False, fill_value=np.nan)


        mesh.lvec.set(1.0)
        mesh.gvec.set(0.0)
        mesh.dm.localToGlobal(mesh.lvec, mesh.gvec, addv=True)
        mesh.dm.globalToLocal(mesh.gvec, mesh.lvec)
        self.ghost_weights = np.rint(mesh.lvec.array)

        # print comm.rank, mesh.lvec.getSizes(), mesh.gvec.getSizes()
        # print comm.rank, &#34;global&#34;, mesh.gvec.array
        # print comm.rank, &#34;local&#34;, mesh.lvec.array.reshape(mesh.nz, mesh.ny, mesh.nx)


        # Cost function variables
        self.observation = {}
        self.prior = {}


        # Initialise linear solver
        self.ksp = self._initialise_ksp()
        self.ksp_T = self._initialise_ksp() # &lt;- need to pass transposed mat

        self.temperature = self.mesh.gvec.duplicate()
        self._temperature = self.mesh.gvec.duplicate()


    def _initialise_ksp(self, matrix=None, solver=&#39;bcgs&#39;, atol=1e-10, rtol=1e-50):
        &#34;&#34;&#34;
        Initialise linear solver object
        &#34;&#34;&#34;
        if matrix is None:
            matrix = self.mesh.mat

        ksp = PETSc.KSP().create(comm)
        ksp.setType(solver)
        ksp.setOperators(matrix)
        ksp.setTolerances(atol, rtol)
        ksp.setFromOptions()
        return ksp

    
    def add_prior(self, **kwargs):
        &#34;&#34;&#34;
        All priors will be inversion variables,
        but not all inversion variables will have priors.

            ARGS
                prior  : tuple(prior, uncertainty)

        &#34;&#34;&#34;
        for arg in kwargs:
            p = list(kwargs[arg])
            p[0] = np.ma.array(p[0], mask=p[1]==0.0)
            self.prior[arg] = p


    def add_observation(self, **kwargs):
        &#34;&#34;&#34;
            ARGS
                obs    : tuple(obs, uncertainty, coords)


        Similar to add_prior() but interpolates onto the mesh
        &#34;&#34;&#34;
        fill_value = self.interp.fill_value
        nx, ny, nz = self.nx, self.ny, self.nz

        for arg in kwargs:
            o = list(kwargs[arg])
            o[0] = np.ma.array(o[0], mask=o[1]==0.0)
            if len(o) == 2 or o[-1] is None:
                # constant across the whole field
                ghost_weight = 1.0/self.ghost_weights
            else:
                xi = o[2]
                self.interp.fill_value = -1.
                self.interp.values = self.ghost_weights.reshape(self.mesh.n)
                w = self.interp(xi)
                ghost_weight = 1.0/np.floor(w+1e-12) # eliminate round-off error
                ghost_weight[ghost_weight==-1.] = 0.0

            o.append(ghost_weight)
            self.observation[arg] = o

        self.interp.fill_value = fill_value


    def add_observation_new(self, **kwargs):

        interp = self.interp
        interp.values = self.ghost_weights.reshape(self.mesh.n)

        for arg in kwargs:
            obs = InvObservation(interp, *kwargs[arg])
            self.observation[arg] = obs

    def add_prior_new(self, **kwargs):

        for arg in kwargs:
            prior = InvPrior(*kwargs[arg])
            self.prior[arg] = prior


    def interpolate(field, xi):
        self.interp.values = field.reshape(self.mesh.n)
        return self.interp(xi)


    def cost(self, x, inv_obj):
        x[np.isnan(x)] = 0.0
        c = (x - inv_obj.v)**2/inv_obj.dv**2
        c *= inv_obj.gweight
        return c.sum()

    def cost_ad(self, x, inv_obj):
        x[np.isnan(x)] = 0.0
        dc = (2.0*x - 2.0*inv_obj.v)/inv_obj.dv**2
        dc *= inv_obj.gweight
        return dc


    def objective_function(self, x, x0, sigma_x0, ghost_weight=1.0):
        x = np.ma.array(x, mask=np.isnan(x))
        C = (x - x0)**2/sigma_x0**2
        C *= ghost_weight
        return C.sum()

    def objective_function_ad(self, x, x0, sigma_x0, ghost_weight=1.0):
        x = np.array(x)
        C_ad = (2.0*x - 2.0*x0)/sigma_x0**2
        C_ad *= ghost_weight
        return C_ad


    def map(self, *args):
        &#34;&#34;&#34;
        Requires a tuple of vectors corresponding to an inversion variable
        these are mapped to the mesh.

        tuple(vec1, vec2, vecN) --&gt; tuple(field1, field2, fieldN)
        &#34;&#34;&#34;

        nf = len(args)
        nl = len(self.lithology_index)

        # preallocate memory
        mesh_variables = np.zeros((nf, self.lithology.size))

        # unpack vector to field
        for i in range(0, nl):
            idx = self.lithology_mask[i]
            for f in range(nf):
                mesh_variables[f,idx] = args[f][i]

        return list(mesh_variables)

    def map_ad(self, *args):
        &#34;&#34;&#34;
        Map mesh variables back to the list
        &#34;&#34;&#34;
        
        nf = len(args)
        nl = len(self.lithology_index)

        lith_variables = np.zeros((nf, self.lithology_index.size))

        for i in range(0, nl):
            idx = self.lithology_mask[i]
            for f in range(nf):
                lith_variables[f,i] += args[f][idx].sum()

        return list(lith_variables)


    def linear_solve(self, matrix=None, rhs=None):

        if matrix == None:
            matrix = self.mesh.construct_matrix()
        if rhs == None:
            rhs = self.mesh.construct_rhs()

        gvec = self.mesh.gvec
        lvec = self.mesh.lvec

        res = self.mesh.temperature

        self.ksp.setOperators(matrix)
        self.ksp.solve(rhs._gdata, res._gdata)
        return res[:].copy()

    def linear_solve_ad(self, T, dT, matrix=None, rhs=None):

        if matrix == None:
            matrix = self.mesh.construct_matrix(in_place=False)
        if rhs == None:
            rhs = self.mesh.construct_rhs(in_place=False)

        gvec = self.mesh.gvec
        lvec = self.mesh.lvec

        res = self.mesh.temperature
        res[:] = T

        # adjoint b vec
        db_ad = lvec.duplicate()

        matrix_T = self.mesh._initialise_matrix()
        matrix.transpose(matrix_T)
        self.ksp_T.setOperators(matrix_T)
        self.ksp_T.solve(rhs._gdata, gvec)
        self.mesh.dm.globalToLocal(gvec, db_ad)


        # adjoint A mat
        dk_ad = np.zeros_like(T)
        solve_lith = np.array(True)

        matrix.scale(-1.0)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
        dT_ad = dT[:]
        
        nl = len(self.lithology_index)
        for i in range(0, nl):
            idx = self.lithology_mask[i]
            idx_n = np.logical_and(idx, dT_ad != 0.0)
            ng = idx_n.any()
            comm.Allreduce([ng, MPI.BOOL], [solve_lith, MPI.BOOL], op=MPI.LOR)
            if solve_lith:
                self.mesh.diffusivity[:] = idx
                dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
                dAdklT = dAdkl * res._gdata
                self.ksp.solve(dAdklT, gvec)
                self.mesh.dm.globalToLocal(gvec, lvec)
                dk_ad[idx] += dT_ad.dot(lvec.array)/idx_n.sum()

        return dk_ad, db_ad.array

    def gradient(self, T):
        gradT = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        return gradT

    def gradient_ad(self, dT, gradT, T):
        # gradT = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        for i in range(0, self.mesh.dim):
            delta = np.mean(np.diff(self.mesh.grid_coords[::-1][i]))
            dT += gradT[i]/(self.mesh.n[i]*delta)
        return dT


    def heatflux(self, T, k):
        gradT = self.gradient(T)
        kn = -k.reshape(self.mesh.n)
        # self.mesh.create_meshVariable(&#39;heatflux&#39;)
        q = kn*np.array(gradT)
        return q.sum(axis=0)

    def heatflux_ad(dq, q, T, k):
        gradT = self.gradient(T)
        kn = -k.reshape(self.mesh.n)

        dqdk = np.array(gradT).sum(axis=0)
        dk = dqdk*dq

        dqdgradT = kn
        dT = np.zeros_like(kn)
        for i in range(0, self.mesh.dim):
            delta = np.mean(np.diff(self.mesh.grid_coords[::-1][i]))
            dqdT = kn/(self.mesh.n[i]*delta)
            dT += dqdT*dq
        
        return dT, dk


    def forward_model(self, x):
        &#34;&#34;&#34;
        x : inversion variables vector
        need to map x to map() and user defined functions
        
        k and H are compulsory (should they be specified in the first part of x?)
        
        &#34;&#34;&#34;
        dx, dy, dz = self.dx, self.dy, self.dz
        nx, ny, nz = self.nx, self.ny, self.nz
        (minX, maxX), (minY, maxY), (minZ, maxZ) = self.mesh.dm.getLocalBoundingBox()
        minBounds = (minX, minY, minZ)
        maxBounds = (maxX, maxY, maxY)

        k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
        q0 = x.array[-1]

        # Unpack vectors onto mesh
        k0, H, a = self.map(k_list, H_list, a_list)
        self.mesh.update_properties(k0, H)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
        b = self.mesh.construct_rhs()

        k = k0.copy()
        error_local  = np.array(True)
        error_global = np.ones(comm.size, dtype=bool)
        i = 0
        while error_global.any():
            k_last = k.copy()

            self.mesh.update_properties(k, H)
            A = self.mesh.construct_matrix()
            self.ksp.setOperators(A)
            self.ksp.solve(b._gdata, self.temperature)
            self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)
            T = self.mesh.lvec.array.copy()

            k = k0*(298.0/T)**a

            error_local = np.absolute(k - k_last).max() &gt; 1e-6
            comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])
            i += 1

        idx_lowerBC = self.mesh.bc[&#39;minZ&#39;][&#39;mask&#39;]
        idx_upperBC = self.mesh.bc[&#39;maxZ&#39;][&#39;mask&#39;]

        # print gradT[nz//2,0,:]
        # print T.reshape(nz,ny,nx)[nz//2, -1, :]
        # print T[idx_lowerBC]

        cost = np.array(0.0)
        sum_cost = np.array(0.0)

        # Cost observations
        if &#39;q&#39; in self.observation:
            obs = self.observation[&#39;q&#39;]

            # Compute heat flux
            gradTz, gradTy, gradTx = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
            heatflux = -k.reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
            q_interp = heatflux.ravel()
            if obs[2] is not None:
                self.interp.values = heatflux
                q_interp = self.interp(obs[2], method=&#39;nearest&#39;)

            cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])


        if &#39;T&#39; in self.observation:
            obs = self.observation[&#39;T&#39;]
            T_interp = T
            if obs[2] is not None:
                self.interp.values = T.reshape(self.mesh.n)
                T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            # out_of_bounds = np.zeros(obs[2].shape[0], dtype=bool)
            # for i, xi in enumerate(obs[2]):
            #     out_of_bounds[i] += (xi &lt; minBounds).any()
            #     out_of_bounds[i] += (xi &gt; maxBounds).any()
            # out_of_bounds[np.isnan(T_interp)] = False
            # T_interp[out_of_bounds] = 0.0
            
            cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])
            # C = (T_interp - obs[0])**2/obs[1]**2
            # C /= self.ghost_weights
            # cost += C.sum()

        comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)


        # Cost priors
        for key, array in [(&#39;T&#39;,T), (&#39;k&#39;,k_list), (&#39;H&#39;,H_list), (&#39;a&#39;,a_list), (&#39;q0&#39;,q0)]:
            if key in self.prior:
                prior = self.prior[key]
                sum_cost += self.objective_function(array, prior[0], prior[1])
        

        return sum_cost



    def tangent_linear(self, x, dx):
        hx, hy, hz = self.dx, self.dy, self.dz
        nx, ny, nz = self.nx, self.ny, self.nz

        k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
        q0 = x.array[-1]
        dk_list, dH_list, da_list = np.array_split(dx.array[:-1], 3)
        dq0 = dx.array[-1]

        # Unpack vectors onto mesh
        k0, H, a = self.map(k_list, H_list, a_list)
        dk0, dH, da = self.map(dk_list, dH_list, da_list)

        

        dAdklT = self.mesh.gvec.duplicate()
        k = k0.copy()
        dk = dk0.copy()

        error_local  = np.array([True])
        error_global = np.ones(comm.size, dtype=bool)
        while error_global.any():
            k_last = k.copy()

            self.mesh.update_properties(k, H)
            self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
            self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
            A = self.mesh.construct_matrix()
            b = self.mesh.construct_rhs()

            self.ksp.solve(b._gdata, self.temperature)

            self.mesh.update_properties(dk, dH)
            self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
            self.mesh.boundary_condition(&#39;minZ&#39;, dq0, flux=True)
            dA = self.mesh.construct_matrix(in_place=False, derivative=True)
            db = self.mesh.construct_rhs(in_place=False)
            
            # dT = A-1*db - A-1*dA*A-1*b
            self.ksp.solve(db._gdata, self._temperature)


            A.scale(-1.0)

            x1 = dA*self.temperature
            self.ksp.solve(x1, self.mesh.gvec)

            self._temperature += self.mesh.gvec


            # dA.mult(self.temperature, self.mesh.gvec)
            # self.ksp.solve(self.mesh.gvec, dT_2)

            # for lith in self.lithology_index:
            #     idx = self.lithology == lith
            #     self.mesh.diffusivity.fill(0.0)
            #     self.mesh.diffusivity[idx] = 1.0
            #     dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
            #     dAdkl.mult(self.temperature, dAdklT)
            #     self.ksp.solve(dAdklT, self.mesh.gvec)
            #     dT_2.array[idx] = self.mesh.gvec.array[idx]



            self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)
            T = self.mesh.lvec.array.copy()
            self.mesh.dm.globalToLocal(self._temperature, self.mesh.lvec)
            dT = self.mesh.lvec.array.copy()

            dkda = np.log(298.0/T)*k0*(298.0/T)**a
            dkdk0 = (298.0/T)**a
            dkdT = -a*k0/T*(298.0/T)**a

            k = k0*(298.0/T)**a
            dk = dkda*da + dkdk0*dk0 + dkdT*dT

            error_local[0] = np.absolute(k - k_last).max() &gt; 1e-6
            comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])



        cost = np.array(0.0)
        sum_cost = np.array(0.0)
        dc = np.array(0.0)
        sum_dc = np.array(0.0)

        # Cost observations
        if &#39;q&#39; in self.observation:
            obs = self.observation[&#39;q&#39;]

            # Compute heat flux
            gradTz, gradTy, gradTx = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
            heatflux = -k.reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
            q_interp = heatflux.ravel()
            
            if obs[2] is not None:
                self.interp.values = heatflux
                q_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])

            # dqdT = k
            dqdTz = -k/(nz*hz)
            dqdTy = -k/(ny*hy)
            dqdTx = -k/(nx*hx)
            dqdk = -(gradTz + gradTy + gradTx)

            # dq = dqdT*dT + dqdk.ravel()*dk
            dq = dqdTz*dT + dqdTy*dT + dqdTx*dT + dqdk.ravel()*dk
            dq_interp = dq
            if obs[2] is not None:
                self.interp.values = dq.reshape(self.mesh.n)
                dq_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            # print obs[-1], &#34;\n&#34;, q_interp, &#34;\n&#34;, dq_interp
            dcdq = self.objective_function_ad(q_interp, obs[0], obs[1], obs[-1])
            # print &#34;tl&#34;, dcdq
            dc += np.sum(dcdq*dq_interp)


        if &#39;T&#39; in self.observation:
            obs = self.observation[&#39;T&#39;]
            T_interp = T
            if obs[2] is not None:
                self.interp.values = T.reshape(self.mesh.n)
                T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])

            dT_interp = dT
            if obs[2] is not None:
                self.interp.values = dT.reshape(self.mesh.n)
                dT_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            dcdT = self.objective_function_ad(T_interp, obs[0], obs[1], obs[-1])
            dc += np.sum(dcdT*dT_interp)

        comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([dc, MPI.DOUBLE], [sum_dc, MPI.DOUBLE], op=MPI.SUM)


        # Cost priors
        for key, array, darray in [(&#39;k&#39;,k_list, dk_list),
                                   (&#39;H&#39;,H_list, dH_list),
                                   (&#39;a&#39;,a_list, da_list),
                                   (&#39;q0&#39;,q0,dq0)]:

            if key in self.prior:
                prior = self.prior[key]
                sum_cost += self.objective_function(array, prior[0], prior[1])

                dcdp = self.objective_function_ad(array, prior[0], prior[1])
                sum_dc += np.sum(dcdp*darray)


        return sum_cost, sum_dc




    def adjoint(self, tao, x, G):
        dx, dy, dz = self.dx, self.dy, self.dz
        nx, ny, nz = self.nx, self.ny, self.nz
        (minX, maxX), (minY, maxY), (minZ, maxZ) = self.mesh.dm.getLocalBoundingBox()

        k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
        q0 = x.array[-1]

        # Unpack vectors onto mesh
        k0, H, a = self.map(k_list, H_list, a_list)
        self.mesh.update_properties(k0, H)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
        b = self.mesh.construct_rhs()

        k = [k0]
        T = [None]

        error_local  = np.array([True])
        error_global = np.ones(comm.size, dtype=bool)
        i = 0
        while error_global.any():
            self.mesh.update_properties(k[i], H)
            A = self.mesh.construct_matrix()
            self.ksp.solve(b._gdata, self.temperature)
            self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)

            T.append(self.mesh.lvec.array.copy())
            k.append(k0*(298.0/T[-1])**a)

            error_local[0] = np.absolute(k[-1] - k[-2]).max() &gt; 1e-6
            comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])
            i += 1


        dT_ad = np.zeros_like(k0)
        dk_ad = np.zeros_like(k0)
        dH_ad = np.zeros_like(k0)
        da_ad = np.zeros_like(k0)
        dq0_ad = np.array(0.0)
        dk_list_ad = np.zeros_like(k_list)
        dH_list_ad = np.zeros_like(H_list)
        da_list_ad = np.zeros_like(a_list)
        dq0_list_ad = np.array(0.0)

        cost = np.array(0.0)
        sum_cost = np.array(0.0)

        # Cost observations
        if self.observation.has_key(&#39;q&#39;):
            obs = self.observation[&#39;q&#39;]

            # Compute heat flux
            gradTz, gradTy, gradTx = np.gradient(T[-1].reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
            heatflux = -k[-1].reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
            q_interp = heatflux.ravel()
            
            if obs[2] is not None:
                self.interp.values = heatflux
                q_interp = self.interp(obs[2], method=&#39;nearest&#39;)

            cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])

            ## AD ##
            dcdq = self.objective_function_ad(q_interp, obs[0], obs[1])
            dq_ad = dcdq*1.0
            if obs[2] is not None:
                dq_interp_ad = dcdq*1.0
                dq_ad = self.interp.adjoint(obs[2], dq_interp_ad, method=&#39;nearest&#39;).ravel()
                # print &#34;ad\n&#34;, dq_interp_ad
                self.mesh.lvec.setArray(dq_ad)
                self.mesh.dm.localToGlobal(self.mesh.lvec, self.mesh.gvec)
                self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
                dq_ad = self.mesh.lvec.array.copy() #/self.ghost_weights
                # print &#34;dq_interp_ad&#34;, dq_ad_interp
                # print obs[-1]
                # print &#34;dq_ad\n&#34;, dq_ad.min(), dq_ad.mean(), dq_ad.max()
                # print &#34;dq_ad\n&#34;, np.hstack([dq_ad[dq_ad&gt;0].reshape(-1,1), self.mesh.coords[dq_ad&gt;0]])
                # print &#34;np.nan&#34;, np.where(dq_ad==np.nan)

            dqdTz = -k[-1]/(nz*dz)
            dqdTy = -k[-1]/(ny*dy)
            dqdTx = -k[-1]/(nx*dz)
            dqdk = -(gradTz + gradTy + gradTx).ravel()

            dk_ad += dqdk*dq_ad
            dT_ad += dqdTx*dq_ad + dqdTy*dq_ad + dqdTz*dq_ad
            # print dT_ad.min(), dT_ad.max()

        if self.observation.has_key(&#39;T&#39;):
            obs = self.observation[&#39;T&#39;]
            T_interp = T[-1]
            if obs[2] is not None:
                self.interp.values = T[-1].reshape(self.mesh.n)
                T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])

            ## AD ##
            dcdT = self.objective_function_ad(T_interp, obs[0], obs[1])
            dT_ad2 = dcdT*1.0
            if obs[2] is not None:
                dT_interp_ad = dcdT*1.0
                dT_ad2 = self.interp.adjoint(obs[2], dq_interp_ad, method=&#39;nearest&#39;).ravel()
            
            self.mesh.lvec.setArray(dT_ad2)
            self.mesh.dm.localToGlobal(self.mesh.lvec, self.mesh.gvec)
            self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
            dT_ad2 = self.mesh.lvec.array.copy()
            # print &#34;dT_ad\n&#34;, dT_ad2.min(), dT_ad2.mean(), dT_ad2.max()

            dT_ad += dT_ad2


        comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)

        # Cost priors
        for key, array, array_ad in [(&#39;k&#39;, k_list, dk_list_ad),
                                     (&#39;H&#39;, H_list, dH_list_ad),
                                     (&#39;a&#39;, a_list, da_list_ad),
                                     (&#39;q0&#39;, q0, dq0_list_ad)]:
            if self.prior.has_key(key):
                prior = self.prior[key]
                sum_cost += self.objective_function(array, prior[0], prior[1])

                ## AD ##
                dcdp = self.objective_function_ad(array, prior[0], prior[1])
                # array_ad += dcdp*1.0

        # print &#34;dT&#34;, comm.rank, dT_ad
        # print &#34;dK&#34;, comm.rank, dk_ad

        dk0_ad = np.zeros_like(k0)

        idx_local = np.array([True])
        idx_global = np.ones(comm.size, dtype=bool)

        idx_lowerBC = self.mesh.bc[&#39;minZ&#39;][&#39;mask&#39;]
        idx_upperBC = self.mesh.bc[&#39;maxZ&#39;][&#39;mask&#39;]


        kspT = PETSc.KSP().create(comm)
        kspT.setType(&#39;bcgs&#39;)
        kspT.setTolerances(1e-12, 1e-12)
        kspT.setFromOptions()
        # kspT.setDM(self.mesh.dm)
        # pc = kspT.getPC()
        # pc.setType(&#39;gamg&#39;)

        dAdklT = self.mesh.gvec.duplicate()


        for j in range(i):
            dkda = np.log(298.0/T[-1-j])*k0*(298.0/T[-1-j])**a
            dkdk0 = (298.0/T[-1-j])**a
            dkdT = -a*k0/T[-1-j]*(298.0/T[-1-j])**a

            dk0_ad += dkdk0*dk_ad
            dT_ad  += dkdT*dk_ad
            da_ad  += dkda*dk_ad

            dk_ad.fill(0.0)


            self.mesh.update_properties(k[-1-j], H)
            self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
            self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
            A = self.mesh.construct_matrix()


            AT = self.mesh._initialise_matrix()
            A.transpose(AT)
            self.mesh.lvec.setArray(dT_ad)
            self.mesh.dm.localToGlobal(self.mesh.lvec, b._gdata)

            kspT.setOperators(AT)
            kspT.solve(b._gdata, self.mesh.gvec)
            self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
            db_ad = self.mesh.lvec.array

            dH_ad += -db_ad
            dH_ad[idx_lowerBC] += db_ad[idx_lowerBC]/dy
            dq0_ad += np.sum(-db_ad[idx_lowerBC]/dy/self.ghost_weights[idx_lowerBC])

            A.scale(-1.0)


            # self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
            # self.mesh.diffusivity.fill(1.0)
            # dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)

            # self.mesh.lvec.setArray(T[-1-j])
            # self.mesh.dm.localToGlobal(self.mesh.lvec, self._temperature)
            # dAdkl.mult(self._temperature, dAdklT)
            # self.ksp.solve(dAdklT, self.mesh.gvec)

            # dk_ad += dT_ad.dot(self.mesh.lvec.array)

            self.mesh.lvec.setArray(T[-1-j])
            self.mesh.dm.localToGlobal(self.mesh.lvec, self._temperature)


            kappa = np.zeros_like(H)

            for l, lith in enumerate(self.lithology_index):
                idx = self.lithology == lith
                idx_dT = dT_ad != 0.0
                idx_n  = np.logical_and(idx, idx_dT)
                idx_local[0] = idx_n.any()
                comm.Allgather([idx_local, MPI.BOOL], [idx_global, MPI.BOOL])
                if idx_global.any():
                    self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
                    kappa.fill(0.0)
                    kappa[idx] = 1.0
                    self.mesh.diffusivity[:] = kappa
                    dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
                    # diag = dAdkl.getDiagonal()
                    # diag.array[idx_upperBC] = 0.0
                    # dAdkl.setDiagonal(diag)
                    dAdkl.mult(self._temperature, dAdklT)
                    self.ksp.setOperators(A)
                    self.ksp.solve(dAdklT, self.mesh.gvec)
                    self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
                    if idx_local[0]:
                        dk_ad[idx_n] += dT_ad.dot(self.mesh.lvec.array)/idx_n.sum()
                    # print self.mesh.lvec.array.mean(), dk_ad.mean(), dk0_ad.mean(), idx_n.any(), idx_n.sum()


            dT_ad.fill(0.0)

        dk0_ad += dk_ad

        kspT.destroy()

        dk0_ad /= self.ghost_weights
        dH_ad /= self.ghost_weights
        da_ad /= self.ghost_weights

        for i, index in enumerate(self.lithology_index):
            idx = self.lithology == index
            dk_list_ad[i] += dk0_ad[idx].sum()
            dH_list_ad[i] += dH_ad[idx].sum()
            da_list_ad[i] += da_ad[idx].sum()


        sum_dk_list_ad = np.zeros_like(dk_list_ad)
        sum_dH_list_ad = np.zeros_like(dk_list_ad)
        sum_da_list_ad = np.zeros_like(dk_list_ad)
        sum_dq0_ad = np.array(0.0)

        comm.Allreduce([dk_list_ad, MPI.DOUBLE], [sum_dk_list_ad, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([dH_list_ad, MPI.DOUBLE], [sum_dH_list_ad, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([da_list_ad, MPI.DOUBLE], [sum_da_list_ad, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([dq0_ad, MPI.DOUBLE], [sum_dq0_ad, MPI.DOUBLE], op=MPI.SUM)


        dq0_list_ad += sum_dq0_ad

        # Procs have unique lithololgy, need to communicate the gradients after vectors are all been packed up
        # I think these fellows ought to have their prior sensitivities added at the end since these are global.
        # for i, index in enumerate(self.lithology_index):
        #     idx = self.lithology == index
        #     dk_list_ad[i] += sum_dk0_ad[idx].sum()
        #     dH_list_ad[i] += sum_dH_ad[idx].sum()
        #     da_list_ad[i] += sum_da_ad[idx].sum()

        # procs should have their part of the sensitivities summed. Even if this doesn&#39;t result in any difference,
        # performance should be improved by communicating smaller arrays

        for key, array, array_ad in [(&#39;k&#39;, k_list, sum_dk_list_ad),
                                     (&#39;H&#39;, H_list, sum_dH_list_ad),
                                     (&#39;a&#39;, a_list, sum_da_list_ad),
                                     (&#39;q0&#39;, q0, sum_dq0_ad)]:
            if key in self.prior:
                prior = self.prior[key]
                array_ad += self.objective_function_ad(array, prior[0], prior[1])


        G.setArray(np.concatenate([sum_dk_list_ad, sum_dH_list_ad, sum_da_list_ad, [sum_dq0_ad]]))

        print(&#34;cost = {}&#34;.format(sum_cost))
        
        return sum_cost</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="conduction.inversion.inverse_conduction.Inversion"><code class="flex name class">
<span>class <span class="ident">Inversion</span></span>
<span>(</span><span>lithology, mesh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Inversion(object):

    def __init__(self, lithology, mesh):
        self.mesh = mesh
        self.lithology = np.array(lithology).ravel()

        # communicate lithology index
        lithology_index = np.unique(lithology)
        lith_min, lith_max = np.array(lithology_index.min(), dtype=float), np.array(lithology_index.max(), dtype=float)
        all_lith_min, all_lith_max = np.array(0.0), np.array(0.0)
        comm.Allreduce([lith_min, MPI.DOUBLE], [all_lith_min, MPI.DOUBLE], op=MPI.MIN)
        comm.Allreduce([lith_max, MPI.DOUBLE], [all_lith_max, MPI.DOUBLE], op=MPI.MAX)

        # self.lithology_index = np.unique(lithology)
        # self.lithology_index.sort()
        self.lithology_index = np.arange(int(all_lith_min), int(all_lith_max)+1)

        self.lithology_mask = np.zeros((len(self.lithology_index), mesh.nn), dtype=bool)

        for i, index in enumerate(self.lithology_index):
            self.lithology_mask[i] = self.lithology == index


        minX, minY, minZ = mesh.coords.min(axis=0)
        maxX, maxY, maxZ = mesh.coords.max(axis=0)


        Xcoords = np.unique(mesh.coords[:,0])
        Ycoords = np.unique(mesh.coords[:,1])
        Zcoords = np.unique(mesh.coords[:,2])

        nx, ny, nz = Xcoords.size, Ycoords.size, Zcoords.size

        self.dx = (maxX - minX)/nx
        self.dy = (maxY - minY)/ny
        self.dz = (maxZ - minZ)/nz

        self.nx = nx
        self.ny = ny
        self.nz = nz


        self.interp = RegularGridInterpolator(mesh.grid_coords[::-1],
                                              np.zeros(mesh.n),
                                              bounds_error=False, fill_value=np.nan)


        mesh.lvec.set(1.0)
        mesh.gvec.set(0.0)
        mesh.dm.localToGlobal(mesh.lvec, mesh.gvec, addv=True)
        mesh.dm.globalToLocal(mesh.gvec, mesh.lvec)
        self.ghost_weights = np.rint(mesh.lvec.array)

        # print comm.rank, mesh.lvec.getSizes(), mesh.gvec.getSizes()
        # print comm.rank, &#34;global&#34;, mesh.gvec.array
        # print comm.rank, &#34;local&#34;, mesh.lvec.array.reshape(mesh.nz, mesh.ny, mesh.nx)


        # Cost function variables
        self.observation = {}
        self.prior = {}


        # Initialise linear solver
        self.ksp = self._initialise_ksp()
        self.ksp_T = self._initialise_ksp() # &lt;- need to pass transposed mat

        self.temperature = self.mesh.gvec.duplicate()
        self._temperature = self.mesh.gvec.duplicate()


    def _initialise_ksp(self, matrix=None, solver=&#39;bcgs&#39;, atol=1e-10, rtol=1e-50):
        &#34;&#34;&#34;
        Initialise linear solver object
        &#34;&#34;&#34;
        if matrix is None:
            matrix = self.mesh.mat

        ksp = PETSc.KSP().create(comm)
        ksp.setType(solver)
        ksp.setOperators(matrix)
        ksp.setTolerances(atol, rtol)
        ksp.setFromOptions()
        return ksp

    
    def add_prior(self, **kwargs):
        &#34;&#34;&#34;
        All priors will be inversion variables,
        but not all inversion variables will have priors.

            ARGS
                prior  : tuple(prior, uncertainty)

        &#34;&#34;&#34;
        for arg in kwargs:
            p = list(kwargs[arg])
            p[0] = np.ma.array(p[0], mask=p[1]==0.0)
            self.prior[arg] = p


    def add_observation(self, **kwargs):
        &#34;&#34;&#34;
            ARGS
                obs    : tuple(obs, uncertainty, coords)


        Similar to add_prior() but interpolates onto the mesh
        &#34;&#34;&#34;
        fill_value = self.interp.fill_value
        nx, ny, nz = self.nx, self.ny, self.nz

        for arg in kwargs:
            o = list(kwargs[arg])
            o[0] = np.ma.array(o[0], mask=o[1]==0.0)
            if len(o) == 2 or o[-1] is None:
                # constant across the whole field
                ghost_weight = 1.0/self.ghost_weights
            else:
                xi = o[2]
                self.interp.fill_value = -1.
                self.interp.values = self.ghost_weights.reshape(self.mesh.n)
                w = self.interp(xi)
                ghost_weight = 1.0/np.floor(w+1e-12) # eliminate round-off error
                ghost_weight[ghost_weight==-1.] = 0.0

            o.append(ghost_weight)
            self.observation[arg] = o

        self.interp.fill_value = fill_value


    def add_observation_new(self, **kwargs):

        interp = self.interp
        interp.values = self.ghost_weights.reshape(self.mesh.n)

        for arg in kwargs:
            obs = InvObservation(interp, *kwargs[arg])
            self.observation[arg] = obs

    def add_prior_new(self, **kwargs):

        for arg in kwargs:
            prior = InvPrior(*kwargs[arg])
            self.prior[arg] = prior


    def interpolate(field, xi):
        self.interp.values = field.reshape(self.mesh.n)
        return self.interp(xi)


    def cost(self, x, inv_obj):
        x[np.isnan(x)] = 0.0
        c = (x - inv_obj.v)**2/inv_obj.dv**2
        c *= inv_obj.gweight
        return c.sum()

    def cost_ad(self, x, inv_obj):
        x[np.isnan(x)] = 0.0
        dc = (2.0*x - 2.0*inv_obj.v)/inv_obj.dv**2
        dc *= inv_obj.gweight
        return dc


    def objective_function(self, x, x0, sigma_x0, ghost_weight=1.0):
        x = np.ma.array(x, mask=np.isnan(x))
        C = (x - x0)**2/sigma_x0**2
        C *= ghost_weight
        return C.sum()

    def objective_function_ad(self, x, x0, sigma_x0, ghost_weight=1.0):
        x = np.array(x)
        C_ad = (2.0*x - 2.0*x0)/sigma_x0**2
        C_ad *= ghost_weight
        return C_ad


    def map(self, *args):
        &#34;&#34;&#34;
        Requires a tuple of vectors corresponding to an inversion variable
        these are mapped to the mesh.

        tuple(vec1, vec2, vecN) --&gt; tuple(field1, field2, fieldN)
        &#34;&#34;&#34;

        nf = len(args)
        nl = len(self.lithology_index)

        # preallocate memory
        mesh_variables = np.zeros((nf, self.lithology.size))

        # unpack vector to field
        for i in range(0, nl):
            idx = self.lithology_mask[i]
            for f in range(nf):
                mesh_variables[f,idx] = args[f][i]

        return list(mesh_variables)

    def map_ad(self, *args):
        &#34;&#34;&#34;
        Map mesh variables back to the list
        &#34;&#34;&#34;
        
        nf = len(args)
        nl = len(self.lithology_index)

        lith_variables = np.zeros((nf, self.lithology_index.size))

        for i in range(0, nl):
            idx = self.lithology_mask[i]
            for f in range(nf):
                lith_variables[f,i] += args[f][idx].sum()

        return list(lith_variables)


    def linear_solve(self, matrix=None, rhs=None):

        if matrix == None:
            matrix = self.mesh.construct_matrix()
        if rhs == None:
            rhs = self.mesh.construct_rhs()

        gvec = self.mesh.gvec
        lvec = self.mesh.lvec

        res = self.mesh.temperature

        self.ksp.setOperators(matrix)
        self.ksp.solve(rhs._gdata, res._gdata)
        return res[:].copy()

    def linear_solve_ad(self, T, dT, matrix=None, rhs=None):

        if matrix == None:
            matrix = self.mesh.construct_matrix(in_place=False)
        if rhs == None:
            rhs = self.mesh.construct_rhs(in_place=False)

        gvec = self.mesh.gvec
        lvec = self.mesh.lvec

        res = self.mesh.temperature
        res[:] = T

        # adjoint b vec
        db_ad = lvec.duplicate()

        matrix_T = self.mesh._initialise_matrix()
        matrix.transpose(matrix_T)
        self.ksp_T.setOperators(matrix_T)
        self.ksp_T.solve(rhs._gdata, gvec)
        self.mesh.dm.globalToLocal(gvec, db_ad)


        # adjoint A mat
        dk_ad = np.zeros_like(T)
        solve_lith = np.array(True)

        matrix.scale(-1.0)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
        dT_ad = dT[:]
        
        nl = len(self.lithology_index)
        for i in range(0, nl):
            idx = self.lithology_mask[i]
            idx_n = np.logical_and(idx, dT_ad != 0.0)
            ng = idx_n.any()
            comm.Allreduce([ng, MPI.BOOL], [solve_lith, MPI.BOOL], op=MPI.LOR)
            if solve_lith:
                self.mesh.diffusivity[:] = idx
                dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
                dAdklT = dAdkl * res._gdata
                self.ksp.solve(dAdklT, gvec)
                self.mesh.dm.globalToLocal(gvec, lvec)
                dk_ad[idx] += dT_ad.dot(lvec.array)/idx_n.sum()

        return dk_ad, db_ad.array

    def gradient(self, T):
        gradT = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        return gradT

    def gradient_ad(self, dT, gradT, T):
        # gradT = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        for i in range(0, self.mesh.dim):
            delta = np.mean(np.diff(self.mesh.grid_coords[::-1][i]))
            dT += gradT[i]/(self.mesh.n[i]*delta)
        return dT


    def heatflux(self, T, k):
        gradT = self.gradient(T)
        kn = -k.reshape(self.mesh.n)
        # self.mesh.create_meshVariable(&#39;heatflux&#39;)
        q = kn*np.array(gradT)
        return q.sum(axis=0)

    def heatflux_ad(dq, q, T, k):
        gradT = self.gradient(T)
        kn = -k.reshape(self.mesh.n)

        dqdk = np.array(gradT).sum(axis=0)
        dk = dqdk*dq

        dqdgradT = kn
        dT = np.zeros_like(kn)
        for i in range(0, self.mesh.dim):
            delta = np.mean(np.diff(self.mesh.grid_coords[::-1][i]))
            dqdT = kn/(self.mesh.n[i]*delta)
            dT += dqdT*dq
        
        return dT, dk


    def forward_model(self, x):
        &#34;&#34;&#34;
        x : inversion variables vector
        need to map x to map() and user defined functions
        
        k and H are compulsory (should they be specified in the first part of x?)
        
        &#34;&#34;&#34;
        dx, dy, dz = self.dx, self.dy, self.dz
        nx, ny, nz = self.nx, self.ny, self.nz
        (minX, maxX), (minY, maxY), (minZ, maxZ) = self.mesh.dm.getLocalBoundingBox()
        minBounds = (minX, minY, minZ)
        maxBounds = (maxX, maxY, maxY)

        k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
        q0 = x.array[-1]

        # Unpack vectors onto mesh
        k0, H, a = self.map(k_list, H_list, a_list)
        self.mesh.update_properties(k0, H)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
        b = self.mesh.construct_rhs()

        k = k0.copy()
        error_local  = np.array(True)
        error_global = np.ones(comm.size, dtype=bool)
        i = 0
        while error_global.any():
            k_last = k.copy()

            self.mesh.update_properties(k, H)
            A = self.mesh.construct_matrix()
            self.ksp.setOperators(A)
            self.ksp.solve(b._gdata, self.temperature)
            self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)
            T = self.mesh.lvec.array.copy()

            k = k0*(298.0/T)**a

            error_local = np.absolute(k - k_last).max() &gt; 1e-6
            comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])
            i += 1

        idx_lowerBC = self.mesh.bc[&#39;minZ&#39;][&#39;mask&#39;]
        idx_upperBC = self.mesh.bc[&#39;maxZ&#39;][&#39;mask&#39;]

        # print gradT[nz//2,0,:]
        # print T.reshape(nz,ny,nx)[nz//2, -1, :]
        # print T[idx_lowerBC]

        cost = np.array(0.0)
        sum_cost = np.array(0.0)

        # Cost observations
        if &#39;q&#39; in self.observation:
            obs = self.observation[&#39;q&#39;]

            # Compute heat flux
            gradTz, gradTy, gradTx = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
            heatflux = -k.reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
            q_interp = heatflux.ravel()
            if obs[2] is not None:
                self.interp.values = heatflux
                q_interp = self.interp(obs[2], method=&#39;nearest&#39;)

            cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])


        if &#39;T&#39; in self.observation:
            obs = self.observation[&#39;T&#39;]
            T_interp = T
            if obs[2] is not None:
                self.interp.values = T.reshape(self.mesh.n)
                T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            # out_of_bounds = np.zeros(obs[2].shape[0], dtype=bool)
            # for i, xi in enumerate(obs[2]):
            #     out_of_bounds[i] += (xi &lt; minBounds).any()
            #     out_of_bounds[i] += (xi &gt; maxBounds).any()
            # out_of_bounds[np.isnan(T_interp)] = False
            # T_interp[out_of_bounds] = 0.0
            
            cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])
            # C = (T_interp - obs[0])**2/obs[1]**2
            # C /= self.ghost_weights
            # cost += C.sum()

        comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)


        # Cost priors
        for key, array in [(&#39;T&#39;,T), (&#39;k&#39;,k_list), (&#39;H&#39;,H_list), (&#39;a&#39;,a_list), (&#39;q0&#39;,q0)]:
            if key in self.prior:
                prior = self.prior[key]
                sum_cost += self.objective_function(array, prior[0], prior[1])
        

        return sum_cost



    def tangent_linear(self, x, dx):
        hx, hy, hz = self.dx, self.dy, self.dz
        nx, ny, nz = self.nx, self.ny, self.nz

        k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
        q0 = x.array[-1]
        dk_list, dH_list, da_list = np.array_split(dx.array[:-1], 3)
        dq0 = dx.array[-1]

        # Unpack vectors onto mesh
        k0, H, a = self.map(k_list, H_list, a_list)
        dk0, dH, da = self.map(dk_list, dH_list, da_list)

        

        dAdklT = self.mesh.gvec.duplicate()
        k = k0.copy()
        dk = dk0.copy()

        error_local  = np.array([True])
        error_global = np.ones(comm.size, dtype=bool)
        while error_global.any():
            k_last = k.copy()

            self.mesh.update_properties(k, H)
            self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
            self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
            A = self.mesh.construct_matrix()
            b = self.mesh.construct_rhs()

            self.ksp.solve(b._gdata, self.temperature)

            self.mesh.update_properties(dk, dH)
            self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
            self.mesh.boundary_condition(&#39;minZ&#39;, dq0, flux=True)
            dA = self.mesh.construct_matrix(in_place=False, derivative=True)
            db = self.mesh.construct_rhs(in_place=False)
            
            # dT = A-1*db - A-1*dA*A-1*b
            self.ksp.solve(db._gdata, self._temperature)


            A.scale(-1.0)

            x1 = dA*self.temperature
            self.ksp.solve(x1, self.mesh.gvec)

            self._temperature += self.mesh.gvec


            # dA.mult(self.temperature, self.mesh.gvec)
            # self.ksp.solve(self.mesh.gvec, dT_2)

            # for lith in self.lithology_index:
            #     idx = self.lithology == lith
            #     self.mesh.diffusivity.fill(0.0)
            #     self.mesh.diffusivity[idx] = 1.0
            #     dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
            #     dAdkl.mult(self.temperature, dAdklT)
            #     self.ksp.solve(dAdklT, self.mesh.gvec)
            #     dT_2.array[idx] = self.mesh.gvec.array[idx]



            self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)
            T = self.mesh.lvec.array.copy()
            self.mesh.dm.globalToLocal(self._temperature, self.mesh.lvec)
            dT = self.mesh.lvec.array.copy()

            dkda = np.log(298.0/T)*k0*(298.0/T)**a
            dkdk0 = (298.0/T)**a
            dkdT = -a*k0/T*(298.0/T)**a

            k = k0*(298.0/T)**a
            dk = dkda*da + dkdk0*dk0 + dkdT*dT

            error_local[0] = np.absolute(k - k_last).max() &gt; 1e-6
            comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])



        cost = np.array(0.0)
        sum_cost = np.array(0.0)
        dc = np.array(0.0)
        sum_dc = np.array(0.0)

        # Cost observations
        if &#39;q&#39; in self.observation:
            obs = self.observation[&#39;q&#39;]

            # Compute heat flux
            gradTz, gradTy, gradTx = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
            heatflux = -k.reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
            q_interp = heatflux.ravel()
            
            if obs[2] is not None:
                self.interp.values = heatflux
                q_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])

            # dqdT = k
            dqdTz = -k/(nz*hz)
            dqdTy = -k/(ny*hy)
            dqdTx = -k/(nx*hx)
            dqdk = -(gradTz + gradTy + gradTx)

            # dq = dqdT*dT + dqdk.ravel()*dk
            dq = dqdTz*dT + dqdTy*dT + dqdTx*dT + dqdk.ravel()*dk
            dq_interp = dq
            if obs[2] is not None:
                self.interp.values = dq.reshape(self.mesh.n)
                dq_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            # print obs[-1], &#34;\n&#34;, q_interp, &#34;\n&#34;, dq_interp
            dcdq = self.objective_function_ad(q_interp, obs[0], obs[1], obs[-1])
            # print &#34;tl&#34;, dcdq
            dc += np.sum(dcdq*dq_interp)


        if &#39;T&#39; in self.observation:
            obs = self.observation[&#39;T&#39;]
            T_interp = T
            if obs[2] is not None:
                self.interp.values = T.reshape(self.mesh.n)
                T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])

            dT_interp = dT
            if obs[2] is not None:
                self.interp.values = dT.reshape(self.mesh.n)
                dT_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            dcdT = self.objective_function_ad(T_interp, obs[0], obs[1], obs[-1])
            dc += np.sum(dcdT*dT_interp)

        comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([dc, MPI.DOUBLE], [sum_dc, MPI.DOUBLE], op=MPI.SUM)


        # Cost priors
        for key, array, darray in [(&#39;k&#39;,k_list, dk_list),
                                   (&#39;H&#39;,H_list, dH_list),
                                   (&#39;a&#39;,a_list, da_list),
                                   (&#39;q0&#39;,q0,dq0)]:

            if key in self.prior:
                prior = self.prior[key]
                sum_cost += self.objective_function(array, prior[0], prior[1])

                dcdp = self.objective_function_ad(array, prior[0], prior[1])
                sum_dc += np.sum(dcdp*darray)


        return sum_cost, sum_dc




    def adjoint(self, tao, x, G):
        dx, dy, dz = self.dx, self.dy, self.dz
        nx, ny, nz = self.nx, self.ny, self.nz
        (minX, maxX), (minY, maxY), (minZ, maxZ) = self.mesh.dm.getLocalBoundingBox()

        k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
        q0 = x.array[-1]

        # Unpack vectors onto mesh
        k0, H, a = self.map(k_list, H_list, a_list)
        self.mesh.update_properties(k0, H)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
        b = self.mesh.construct_rhs()

        k = [k0]
        T = [None]

        error_local  = np.array([True])
        error_global = np.ones(comm.size, dtype=bool)
        i = 0
        while error_global.any():
            self.mesh.update_properties(k[i], H)
            A = self.mesh.construct_matrix()
            self.ksp.solve(b._gdata, self.temperature)
            self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)

            T.append(self.mesh.lvec.array.copy())
            k.append(k0*(298.0/T[-1])**a)

            error_local[0] = np.absolute(k[-1] - k[-2]).max() &gt; 1e-6
            comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])
            i += 1


        dT_ad = np.zeros_like(k0)
        dk_ad = np.zeros_like(k0)
        dH_ad = np.zeros_like(k0)
        da_ad = np.zeros_like(k0)
        dq0_ad = np.array(0.0)
        dk_list_ad = np.zeros_like(k_list)
        dH_list_ad = np.zeros_like(H_list)
        da_list_ad = np.zeros_like(a_list)
        dq0_list_ad = np.array(0.0)

        cost = np.array(0.0)
        sum_cost = np.array(0.0)

        # Cost observations
        if self.observation.has_key(&#39;q&#39;):
            obs = self.observation[&#39;q&#39;]

            # Compute heat flux
            gradTz, gradTy, gradTx = np.gradient(T[-1].reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
            heatflux = -k[-1].reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
            q_interp = heatflux.ravel()
            
            if obs[2] is not None:
                self.interp.values = heatflux
                q_interp = self.interp(obs[2], method=&#39;nearest&#39;)

            cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])

            ## AD ##
            dcdq = self.objective_function_ad(q_interp, obs[0], obs[1])
            dq_ad = dcdq*1.0
            if obs[2] is not None:
                dq_interp_ad = dcdq*1.0
                dq_ad = self.interp.adjoint(obs[2], dq_interp_ad, method=&#39;nearest&#39;).ravel()
                # print &#34;ad\n&#34;, dq_interp_ad
                self.mesh.lvec.setArray(dq_ad)
                self.mesh.dm.localToGlobal(self.mesh.lvec, self.mesh.gvec)
                self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
                dq_ad = self.mesh.lvec.array.copy() #/self.ghost_weights
                # print &#34;dq_interp_ad&#34;, dq_ad_interp
                # print obs[-1]
                # print &#34;dq_ad\n&#34;, dq_ad.min(), dq_ad.mean(), dq_ad.max()
                # print &#34;dq_ad\n&#34;, np.hstack([dq_ad[dq_ad&gt;0].reshape(-1,1), self.mesh.coords[dq_ad&gt;0]])
                # print &#34;np.nan&#34;, np.where(dq_ad==np.nan)

            dqdTz = -k[-1]/(nz*dz)
            dqdTy = -k[-1]/(ny*dy)
            dqdTx = -k[-1]/(nx*dz)
            dqdk = -(gradTz + gradTy + gradTx).ravel()

            dk_ad += dqdk*dq_ad
            dT_ad += dqdTx*dq_ad + dqdTy*dq_ad + dqdTz*dq_ad
            # print dT_ad.min(), dT_ad.max()

        if self.observation.has_key(&#39;T&#39;):
            obs = self.observation[&#39;T&#39;]
            T_interp = T[-1]
            if obs[2] is not None:
                self.interp.values = T[-1].reshape(self.mesh.n)
                T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
            cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])

            ## AD ##
            dcdT = self.objective_function_ad(T_interp, obs[0], obs[1])
            dT_ad2 = dcdT*1.0
            if obs[2] is not None:
                dT_interp_ad = dcdT*1.0
                dT_ad2 = self.interp.adjoint(obs[2], dq_interp_ad, method=&#39;nearest&#39;).ravel()
            
            self.mesh.lvec.setArray(dT_ad2)
            self.mesh.dm.localToGlobal(self.mesh.lvec, self.mesh.gvec)
            self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
            dT_ad2 = self.mesh.lvec.array.copy()
            # print &#34;dT_ad\n&#34;, dT_ad2.min(), dT_ad2.mean(), dT_ad2.max()

            dT_ad += dT_ad2


        comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)

        # Cost priors
        for key, array, array_ad in [(&#39;k&#39;, k_list, dk_list_ad),
                                     (&#39;H&#39;, H_list, dH_list_ad),
                                     (&#39;a&#39;, a_list, da_list_ad),
                                     (&#39;q0&#39;, q0, dq0_list_ad)]:
            if self.prior.has_key(key):
                prior = self.prior[key]
                sum_cost += self.objective_function(array, prior[0], prior[1])

                ## AD ##
                dcdp = self.objective_function_ad(array, prior[0], prior[1])
                # array_ad += dcdp*1.0

        # print &#34;dT&#34;, comm.rank, dT_ad
        # print &#34;dK&#34;, comm.rank, dk_ad

        dk0_ad = np.zeros_like(k0)

        idx_local = np.array([True])
        idx_global = np.ones(comm.size, dtype=bool)

        idx_lowerBC = self.mesh.bc[&#39;minZ&#39;][&#39;mask&#39;]
        idx_upperBC = self.mesh.bc[&#39;maxZ&#39;][&#39;mask&#39;]


        kspT = PETSc.KSP().create(comm)
        kspT.setType(&#39;bcgs&#39;)
        kspT.setTolerances(1e-12, 1e-12)
        kspT.setFromOptions()
        # kspT.setDM(self.mesh.dm)
        # pc = kspT.getPC()
        # pc.setType(&#39;gamg&#39;)

        dAdklT = self.mesh.gvec.duplicate()


        for j in range(i):
            dkda = np.log(298.0/T[-1-j])*k0*(298.0/T[-1-j])**a
            dkdk0 = (298.0/T[-1-j])**a
            dkdT = -a*k0/T[-1-j]*(298.0/T[-1-j])**a

            dk0_ad += dkdk0*dk_ad
            dT_ad  += dkdT*dk_ad
            da_ad  += dkda*dk_ad

            dk_ad.fill(0.0)


            self.mesh.update_properties(k[-1-j], H)
            self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
            self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
            A = self.mesh.construct_matrix()


            AT = self.mesh._initialise_matrix()
            A.transpose(AT)
            self.mesh.lvec.setArray(dT_ad)
            self.mesh.dm.localToGlobal(self.mesh.lvec, b._gdata)

            kspT.setOperators(AT)
            kspT.solve(b._gdata, self.mesh.gvec)
            self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
            db_ad = self.mesh.lvec.array

            dH_ad += -db_ad
            dH_ad[idx_lowerBC] += db_ad[idx_lowerBC]/dy
            dq0_ad += np.sum(-db_ad[idx_lowerBC]/dy/self.ghost_weights[idx_lowerBC])

            A.scale(-1.0)


            # self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
            # self.mesh.diffusivity.fill(1.0)
            # dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)

            # self.mesh.lvec.setArray(T[-1-j])
            # self.mesh.dm.localToGlobal(self.mesh.lvec, self._temperature)
            # dAdkl.mult(self._temperature, dAdklT)
            # self.ksp.solve(dAdklT, self.mesh.gvec)

            # dk_ad += dT_ad.dot(self.mesh.lvec.array)

            self.mesh.lvec.setArray(T[-1-j])
            self.mesh.dm.localToGlobal(self.mesh.lvec, self._temperature)


            kappa = np.zeros_like(H)

            for l, lith in enumerate(self.lithology_index):
                idx = self.lithology == lith
                idx_dT = dT_ad != 0.0
                idx_n  = np.logical_and(idx, idx_dT)
                idx_local[0] = idx_n.any()
                comm.Allgather([idx_local, MPI.BOOL], [idx_global, MPI.BOOL])
                if idx_global.any():
                    self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
                    kappa.fill(0.0)
                    kappa[idx] = 1.0
                    self.mesh.diffusivity[:] = kappa
                    dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
                    # diag = dAdkl.getDiagonal()
                    # diag.array[idx_upperBC] = 0.0
                    # dAdkl.setDiagonal(diag)
                    dAdkl.mult(self._temperature, dAdklT)
                    self.ksp.setOperators(A)
                    self.ksp.solve(dAdklT, self.mesh.gvec)
                    self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
                    if idx_local[0]:
                        dk_ad[idx_n] += dT_ad.dot(self.mesh.lvec.array)/idx_n.sum()
                    # print self.mesh.lvec.array.mean(), dk_ad.mean(), dk0_ad.mean(), idx_n.any(), idx_n.sum()


            dT_ad.fill(0.0)

        dk0_ad += dk_ad

        kspT.destroy()

        dk0_ad /= self.ghost_weights
        dH_ad /= self.ghost_weights
        da_ad /= self.ghost_weights

        for i, index in enumerate(self.lithology_index):
            idx = self.lithology == index
            dk_list_ad[i] += dk0_ad[idx].sum()
            dH_list_ad[i] += dH_ad[idx].sum()
            da_list_ad[i] += da_ad[idx].sum()


        sum_dk_list_ad = np.zeros_like(dk_list_ad)
        sum_dH_list_ad = np.zeros_like(dk_list_ad)
        sum_da_list_ad = np.zeros_like(dk_list_ad)
        sum_dq0_ad = np.array(0.0)

        comm.Allreduce([dk_list_ad, MPI.DOUBLE], [sum_dk_list_ad, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([dH_list_ad, MPI.DOUBLE], [sum_dH_list_ad, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([da_list_ad, MPI.DOUBLE], [sum_da_list_ad, MPI.DOUBLE], op=MPI.SUM)
        comm.Allreduce([dq0_ad, MPI.DOUBLE], [sum_dq0_ad, MPI.DOUBLE], op=MPI.SUM)


        dq0_list_ad += sum_dq0_ad

        # Procs have unique lithololgy, need to communicate the gradients after vectors are all been packed up
        # I think these fellows ought to have their prior sensitivities added at the end since these are global.
        # for i, index in enumerate(self.lithology_index):
        #     idx = self.lithology == index
        #     dk_list_ad[i] += sum_dk0_ad[idx].sum()
        #     dH_list_ad[i] += sum_dH_ad[idx].sum()
        #     da_list_ad[i] += sum_da_ad[idx].sum()

        # procs should have their part of the sensitivities summed. Even if this doesn&#39;t result in any difference,
        # performance should be improved by communicating smaller arrays

        for key, array, array_ad in [(&#39;k&#39;, k_list, sum_dk_list_ad),
                                     (&#39;H&#39;, H_list, sum_dH_list_ad),
                                     (&#39;a&#39;, a_list, sum_da_list_ad),
                                     (&#39;q0&#39;, q0, sum_dq0_ad)]:
            if key in self.prior:
                prior = self.prior[key]
                array_ad += self.objective_function_ad(array, prior[0], prior[1])


        G.setArray(np.concatenate([sum_dk_list_ad, sum_dH_list_ad, sum_da_list_ad, [sum_dq0_ad]]))

        print(&#34;cost = {}&#34;.format(sum_cost))
        
        return sum_cost</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="conduction.inversion.inverse_conduction.Inversion.add_observation"><code class="name flex">
<span>def <span class="ident">add_observation</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>ARGS
obs
: tuple(obs, uncertainty, coords)</p>
<p>Similar to add_prior() but interpolates onto the mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_observation(self, **kwargs):
    &#34;&#34;&#34;
        ARGS
            obs    : tuple(obs, uncertainty, coords)


    Similar to add_prior() but interpolates onto the mesh
    &#34;&#34;&#34;
    fill_value = self.interp.fill_value
    nx, ny, nz = self.nx, self.ny, self.nz

    for arg in kwargs:
        o = list(kwargs[arg])
        o[0] = np.ma.array(o[0], mask=o[1]==0.0)
        if len(o) == 2 or o[-1] is None:
            # constant across the whole field
            ghost_weight = 1.0/self.ghost_weights
        else:
            xi = o[2]
            self.interp.fill_value = -1.
            self.interp.values = self.ghost_weights.reshape(self.mesh.n)
            w = self.interp(xi)
            ghost_weight = 1.0/np.floor(w+1e-12) # eliminate round-off error
            ghost_weight[ghost_weight==-1.] = 0.0

        o.append(ghost_weight)
        self.observation[arg] = o

    self.interp.fill_value = fill_value</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.add_observation_new"><code class="name flex">
<span>def <span class="ident">add_observation_new</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_observation_new(self, **kwargs):

    interp = self.interp
    interp.values = self.ghost_weights.reshape(self.mesh.n)

    for arg in kwargs:
        obs = InvObservation(interp, *kwargs[arg])
        self.observation[arg] = obs</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.add_prior"><code class="name flex">
<span>def <span class="ident">add_prior</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>All priors will be inversion variables,
but not all inversion variables will have priors.</p>
<pre><code>ARGS
    prior  : tuple(prior, uncertainty)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_prior(self, **kwargs):
    &#34;&#34;&#34;
    All priors will be inversion variables,
    but not all inversion variables will have priors.

        ARGS
            prior  : tuple(prior, uncertainty)

    &#34;&#34;&#34;
    for arg in kwargs:
        p = list(kwargs[arg])
        p[0] = np.ma.array(p[0], mask=p[1]==0.0)
        self.prior[arg] = p</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.add_prior_new"><code class="name flex">
<span>def <span class="ident">add_prior_new</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_prior_new(self, **kwargs):

    for arg in kwargs:
        prior = InvPrior(*kwargs[arg])
        self.prior[arg] = prior</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.adjoint"><code class="name flex">
<span>def <span class="ident">adjoint</span></span>(<span>self, tao, x, G)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjoint(self, tao, x, G):
    dx, dy, dz = self.dx, self.dy, self.dz
    nx, ny, nz = self.nx, self.ny, self.nz
    (minX, maxX), (minY, maxY), (minZ, maxZ) = self.mesh.dm.getLocalBoundingBox()

    k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
    q0 = x.array[-1]

    # Unpack vectors onto mesh
    k0, H, a = self.map(k_list, H_list, a_list)
    self.mesh.update_properties(k0, H)
    self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
    self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
    b = self.mesh.construct_rhs()

    k = [k0]
    T = [None]

    error_local  = np.array([True])
    error_global = np.ones(comm.size, dtype=bool)
    i = 0
    while error_global.any():
        self.mesh.update_properties(k[i], H)
        A = self.mesh.construct_matrix()
        self.ksp.solve(b._gdata, self.temperature)
        self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)

        T.append(self.mesh.lvec.array.copy())
        k.append(k0*(298.0/T[-1])**a)

        error_local[0] = np.absolute(k[-1] - k[-2]).max() &gt; 1e-6
        comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])
        i += 1


    dT_ad = np.zeros_like(k0)
    dk_ad = np.zeros_like(k0)
    dH_ad = np.zeros_like(k0)
    da_ad = np.zeros_like(k0)
    dq0_ad = np.array(0.0)
    dk_list_ad = np.zeros_like(k_list)
    dH_list_ad = np.zeros_like(H_list)
    da_list_ad = np.zeros_like(a_list)
    dq0_list_ad = np.array(0.0)

    cost = np.array(0.0)
    sum_cost = np.array(0.0)

    # Cost observations
    if self.observation.has_key(&#39;q&#39;):
        obs = self.observation[&#39;q&#39;]

        # Compute heat flux
        gradTz, gradTy, gradTx = np.gradient(T[-1].reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        heatflux = -k[-1].reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
        q_interp = heatflux.ravel()
        
        if obs[2] is not None:
            self.interp.values = heatflux
            q_interp = self.interp(obs[2], method=&#39;nearest&#39;)

        cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])

        ## AD ##
        dcdq = self.objective_function_ad(q_interp, obs[0], obs[1])
        dq_ad = dcdq*1.0
        if obs[2] is not None:
            dq_interp_ad = dcdq*1.0
            dq_ad = self.interp.adjoint(obs[2], dq_interp_ad, method=&#39;nearest&#39;).ravel()
            # print &#34;ad\n&#34;, dq_interp_ad
            self.mesh.lvec.setArray(dq_ad)
            self.mesh.dm.localToGlobal(self.mesh.lvec, self.mesh.gvec)
            self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
            dq_ad = self.mesh.lvec.array.copy() #/self.ghost_weights
            # print &#34;dq_interp_ad&#34;, dq_ad_interp
            # print obs[-1]
            # print &#34;dq_ad\n&#34;, dq_ad.min(), dq_ad.mean(), dq_ad.max()
            # print &#34;dq_ad\n&#34;, np.hstack([dq_ad[dq_ad&gt;0].reshape(-1,1), self.mesh.coords[dq_ad&gt;0]])
            # print &#34;np.nan&#34;, np.where(dq_ad==np.nan)

        dqdTz = -k[-1]/(nz*dz)
        dqdTy = -k[-1]/(ny*dy)
        dqdTx = -k[-1]/(nx*dz)
        dqdk = -(gradTz + gradTy + gradTx).ravel()

        dk_ad += dqdk*dq_ad
        dT_ad += dqdTx*dq_ad + dqdTy*dq_ad + dqdTz*dq_ad
        # print dT_ad.min(), dT_ad.max()

    if self.observation.has_key(&#39;T&#39;):
        obs = self.observation[&#39;T&#39;]
        T_interp = T[-1]
        if obs[2] is not None:
            self.interp.values = T[-1].reshape(self.mesh.n)
            T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
        cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])

        ## AD ##
        dcdT = self.objective_function_ad(T_interp, obs[0], obs[1])
        dT_ad2 = dcdT*1.0
        if obs[2] is not None:
            dT_interp_ad = dcdT*1.0
            dT_ad2 = self.interp.adjoint(obs[2], dq_interp_ad, method=&#39;nearest&#39;).ravel()
        
        self.mesh.lvec.setArray(dT_ad2)
        self.mesh.dm.localToGlobal(self.mesh.lvec, self.mesh.gvec)
        self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
        dT_ad2 = self.mesh.lvec.array.copy()
        # print &#34;dT_ad\n&#34;, dT_ad2.min(), dT_ad2.mean(), dT_ad2.max()

        dT_ad += dT_ad2


    comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)

    # Cost priors
    for key, array, array_ad in [(&#39;k&#39;, k_list, dk_list_ad),
                                 (&#39;H&#39;, H_list, dH_list_ad),
                                 (&#39;a&#39;, a_list, da_list_ad),
                                 (&#39;q0&#39;, q0, dq0_list_ad)]:
        if self.prior.has_key(key):
            prior = self.prior[key]
            sum_cost += self.objective_function(array, prior[0], prior[1])

            ## AD ##
            dcdp = self.objective_function_ad(array, prior[0], prior[1])
            # array_ad += dcdp*1.0

    # print &#34;dT&#34;, comm.rank, dT_ad
    # print &#34;dK&#34;, comm.rank, dk_ad

    dk0_ad = np.zeros_like(k0)

    idx_local = np.array([True])
    idx_global = np.ones(comm.size, dtype=bool)

    idx_lowerBC = self.mesh.bc[&#39;minZ&#39;][&#39;mask&#39;]
    idx_upperBC = self.mesh.bc[&#39;maxZ&#39;][&#39;mask&#39;]


    kspT = PETSc.KSP().create(comm)
    kspT.setType(&#39;bcgs&#39;)
    kspT.setTolerances(1e-12, 1e-12)
    kspT.setFromOptions()
    # kspT.setDM(self.mesh.dm)
    # pc = kspT.getPC()
    # pc.setType(&#39;gamg&#39;)

    dAdklT = self.mesh.gvec.duplicate()


    for j in range(i):
        dkda = np.log(298.0/T[-1-j])*k0*(298.0/T[-1-j])**a
        dkdk0 = (298.0/T[-1-j])**a
        dkdT = -a*k0/T[-1-j]*(298.0/T[-1-j])**a

        dk0_ad += dkdk0*dk_ad
        dT_ad  += dkdT*dk_ad
        da_ad  += dkda*dk_ad

        dk_ad.fill(0.0)


        self.mesh.update_properties(k[-1-j], H)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
        A = self.mesh.construct_matrix()


        AT = self.mesh._initialise_matrix()
        A.transpose(AT)
        self.mesh.lvec.setArray(dT_ad)
        self.mesh.dm.localToGlobal(self.mesh.lvec, b._gdata)

        kspT.setOperators(AT)
        kspT.solve(b._gdata, self.mesh.gvec)
        self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
        db_ad = self.mesh.lvec.array

        dH_ad += -db_ad
        dH_ad[idx_lowerBC] += db_ad[idx_lowerBC]/dy
        dq0_ad += np.sum(-db_ad[idx_lowerBC]/dy/self.ghost_weights[idx_lowerBC])

        A.scale(-1.0)


        # self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
        # self.mesh.diffusivity.fill(1.0)
        # dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)

        # self.mesh.lvec.setArray(T[-1-j])
        # self.mesh.dm.localToGlobal(self.mesh.lvec, self._temperature)
        # dAdkl.mult(self._temperature, dAdklT)
        # self.ksp.solve(dAdklT, self.mesh.gvec)

        # dk_ad += dT_ad.dot(self.mesh.lvec.array)

        self.mesh.lvec.setArray(T[-1-j])
        self.mesh.dm.localToGlobal(self.mesh.lvec, self._temperature)


        kappa = np.zeros_like(H)

        for l, lith in enumerate(self.lithology_index):
            idx = self.lithology == lith
            idx_dT = dT_ad != 0.0
            idx_n  = np.logical_and(idx, idx_dT)
            idx_local[0] = idx_n.any()
            comm.Allgather([idx_local, MPI.BOOL], [idx_global, MPI.BOOL])
            if idx_global.any():
                self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
                kappa.fill(0.0)
                kappa[idx] = 1.0
                self.mesh.diffusivity[:] = kappa
                dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
                # diag = dAdkl.getDiagonal()
                # diag.array[idx_upperBC] = 0.0
                # dAdkl.setDiagonal(diag)
                dAdkl.mult(self._temperature, dAdklT)
                self.ksp.setOperators(A)
                self.ksp.solve(dAdklT, self.mesh.gvec)
                self.mesh.dm.globalToLocal(self.mesh.gvec, self.mesh.lvec)
                if idx_local[0]:
                    dk_ad[idx_n] += dT_ad.dot(self.mesh.lvec.array)/idx_n.sum()
                # print self.mesh.lvec.array.mean(), dk_ad.mean(), dk0_ad.mean(), idx_n.any(), idx_n.sum()


        dT_ad.fill(0.0)

    dk0_ad += dk_ad

    kspT.destroy()

    dk0_ad /= self.ghost_weights
    dH_ad /= self.ghost_weights
    da_ad /= self.ghost_weights

    for i, index in enumerate(self.lithology_index):
        idx = self.lithology == index
        dk_list_ad[i] += dk0_ad[idx].sum()
        dH_list_ad[i] += dH_ad[idx].sum()
        da_list_ad[i] += da_ad[idx].sum()


    sum_dk_list_ad = np.zeros_like(dk_list_ad)
    sum_dH_list_ad = np.zeros_like(dk_list_ad)
    sum_da_list_ad = np.zeros_like(dk_list_ad)
    sum_dq0_ad = np.array(0.0)

    comm.Allreduce([dk_list_ad, MPI.DOUBLE], [sum_dk_list_ad, MPI.DOUBLE], op=MPI.SUM)
    comm.Allreduce([dH_list_ad, MPI.DOUBLE], [sum_dH_list_ad, MPI.DOUBLE], op=MPI.SUM)
    comm.Allreduce([da_list_ad, MPI.DOUBLE], [sum_da_list_ad, MPI.DOUBLE], op=MPI.SUM)
    comm.Allreduce([dq0_ad, MPI.DOUBLE], [sum_dq0_ad, MPI.DOUBLE], op=MPI.SUM)


    dq0_list_ad += sum_dq0_ad

    # Procs have unique lithololgy, need to communicate the gradients after vectors are all been packed up
    # I think these fellows ought to have their prior sensitivities added at the end since these are global.
    # for i, index in enumerate(self.lithology_index):
    #     idx = self.lithology == index
    #     dk_list_ad[i] += sum_dk0_ad[idx].sum()
    #     dH_list_ad[i] += sum_dH_ad[idx].sum()
    #     da_list_ad[i] += sum_da_ad[idx].sum()

    # procs should have their part of the sensitivities summed. Even if this doesn&#39;t result in any difference,
    # performance should be improved by communicating smaller arrays

    for key, array, array_ad in [(&#39;k&#39;, k_list, sum_dk_list_ad),
                                 (&#39;H&#39;, H_list, sum_dH_list_ad),
                                 (&#39;a&#39;, a_list, sum_da_list_ad),
                                 (&#39;q0&#39;, q0, sum_dq0_ad)]:
        if key in self.prior:
            prior = self.prior[key]
            array_ad += self.objective_function_ad(array, prior[0], prior[1])


    G.setArray(np.concatenate([sum_dk_list_ad, sum_dH_list_ad, sum_da_list_ad, [sum_dq0_ad]]))

    print(&#34;cost = {}&#34;.format(sum_cost))
    
    return sum_cost</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.cost"><code class="name flex">
<span>def <span class="ident">cost</span></span>(<span>self, x, inv_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cost(self, x, inv_obj):
    x[np.isnan(x)] = 0.0
    c = (x - inv_obj.v)**2/inv_obj.dv**2
    c *= inv_obj.gweight
    return c.sum()</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.cost_ad"><code class="name flex">
<span>def <span class="ident">cost_ad</span></span>(<span>self, x, inv_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cost_ad(self, x, inv_obj):
    x[np.isnan(x)] = 0.0
    dc = (2.0*x - 2.0*inv_obj.v)/inv_obj.dv**2
    dc *= inv_obj.gweight
    return dc</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.forward_model"><code class="name flex">
<span>def <span class="ident">forward_model</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>x : inversion variables vector
need to map x to map() and user defined functions</p>
<p>k and H are compulsory (should they be specified in the first part of x?)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_model(self, x):
    &#34;&#34;&#34;
    x : inversion variables vector
    need to map x to map() and user defined functions
    
    k and H are compulsory (should they be specified in the first part of x?)
    
    &#34;&#34;&#34;
    dx, dy, dz = self.dx, self.dy, self.dz
    nx, ny, nz = self.nx, self.ny, self.nz
    (minX, maxX), (minY, maxY), (minZ, maxZ) = self.mesh.dm.getLocalBoundingBox()
    minBounds = (minX, minY, minZ)
    maxBounds = (maxX, maxY, maxY)

    k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
    q0 = x.array[-1]

    # Unpack vectors onto mesh
    k0, H, a = self.map(k_list, H_list, a_list)
    self.mesh.update_properties(k0, H)
    self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
    self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
    b = self.mesh.construct_rhs()

    k = k0.copy()
    error_local  = np.array(True)
    error_global = np.ones(comm.size, dtype=bool)
    i = 0
    while error_global.any():
        k_last = k.copy()

        self.mesh.update_properties(k, H)
        A = self.mesh.construct_matrix()
        self.ksp.setOperators(A)
        self.ksp.solve(b._gdata, self.temperature)
        self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)
        T = self.mesh.lvec.array.copy()

        k = k0*(298.0/T)**a

        error_local = np.absolute(k - k_last).max() &gt; 1e-6
        comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])
        i += 1

    idx_lowerBC = self.mesh.bc[&#39;minZ&#39;][&#39;mask&#39;]
    idx_upperBC = self.mesh.bc[&#39;maxZ&#39;][&#39;mask&#39;]

    # print gradT[nz//2,0,:]
    # print T.reshape(nz,ny,nx)[nz//2, -1, :]
    # print T[idx_lowerBC]

    cost = np.array(0.0)
    sum_cost = np.array(0.0)

    # Cost observations
    if &#39;q&#39; in self.observation:
        obs = self.observation[&#39;q&#39;]

        # Compute heat flux
        gradTz, gradTy, gradTx = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        heatflux = -k.reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
        q_interp = heatflux.ravel()
        if obs[2] is not None:
            self.interp.values = heatflux
            q_interp = self.interp(obs[2], method=&#39;nearest&#39;)

        cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])


    if &#39;T&#39; in self.observation:
        obs = self.observation[&#39;T&#39;]
        T_interp = T
        if obs[2] is not None:
            self.interp.values = T.reshape(self.mesh.n)
            T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
        # out_of_bounds = np.zeros(obs[2].shape[0], dtype=bool)
        # for i, xi in enumerate(obs[2]):
        #     out_of_bounds[i] += (xi &lt; minBounds).any()
        #     out_of_bounds[i] += (xi &gt; maxBounds).any()
        # out_of_bounds[np.isnan(T_interp)] = False
        # T_interp[out_of_bounds] = 0.0
        
        cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])
        # C = (T_interp - obs[0])**2/obs[1]**2
        # C /= self.ghost_weights
        # cost += C.sum()

    comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)


    # Cost priors
    for key, array in [(&#39;T&#39;,T), (&#39;k&#39;,k_list), (&#39;H&#39;,H_list), (&#39;a&#39;,a_list), (&#39;q0&#39;,q0)]:
        if key in self.prior:
            prior = self.prior[key]
            sum_cost += self.objective_function(array, prior[0], prior[1])
    

    return sum_cost</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, T)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient(self, T):
    gradT = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
    return gradT</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.gradient_ad"><code class="name flex">
<span>def <span class="ident">gradient_ad</span></span>(<span>self, dT, gradT, T)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient_ad(self, dT, gradT, T):
    # gradT = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
    for i in range(0, self.mesh.dim):
        delta = np.mean(np.diff(self.mesh.grid_coords[::-1][i]))
        dT += gradT[i]/(self.mesh.n[i]*delta)
    return dT</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.heatflux"><code class="name flex">
<span>def <span class="ident">heatflux</span></span>(<span>self, T, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heatflux(self, T, k):
    gradT = self.gradient(T)
    kn = -k.reshape(self.mesh.n)
    # self.mesh.create_meshVariable(&#39;heatflux&#39;)
    q = kn*np.array(gradT)
    return q.sum(axis=0)</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.heatflux_ad"><code class="name flex">
<span>def <span class="ident">heatflux_ad</span></span>(<span>dq, q, T, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heatflux_ad(dq, q, T, k):
    gradT = self.gradient(T)
    kn = -k.reshape(self.mesh.n)

    dqdk = np.array(gradT).sum(axis=0)
    dk = dqdk*dq

    dqdgradT = kn
    dT = np.zeros_like(kn)
    for i in range(0, self.mesh.dim):
        delta = np.mean(np.diff(self.mesh.grid_coords[::-1][i]))
        dqdT = kn/(self.mesh.n[i]*delta)
        dT += dqdT*dq
    
    return dT, dk</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>field, xi)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(field, xi):
    self.interp.values = field.reshape(self.mesh.n)
    return self.interp(xi)</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.linear_solve"><code class="name flex">
<span>def <span class="ident">linear_solve</span></span>(<span>self, matrix=None, rhs=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_solve(self, matrix=None, rhs=None):

    if matrix == None:
        matrix = self.mesh.construct_matrix()
    if rhs == None:
        rhs = self.mesh.construct_rhs()

    gvec = self.mesh.gvec
    lvec = self.mesh.lvec

    res = self.mesh.temperature

    self.ksp.setOperators(matrix)
    self.ksp.solve(rhs._gdata, res._gdata)
    return res[:].copy()</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.linear_solve_ad"><code class="name flex">
<span>def <span class="ident">linear_solve_ad</span></span>(<span>self, T, dT, matrix=None, rhs=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_solve_ad(self, T, dT, matrix=None, rhs=None):

    if matrix == None:
        matrix = self.mesh.construct_matrix(in_place=False)
    if rhs == None:
        rhs = self.mesh.construct_rhs(in_place=False)

    gvec = self.mesh.gvec
    lvec = self.mesh.lvec

    res = self.mesh.temperature
    res[:] = T

    # adjoint b vec
    db_ad = lvec.duplicate()

    matrix_T = self.mesh._initialise_matrix()
    matrix.transpose(matrix_T)
    self.ksp_T.setOperators(matrix_T)
    self.ksp_T.solve(rhs._gdata, gvec)
    self.mesh.dm.globalToLocal(gvec, db_ad)


    # adjoint A mat
    dk_ad = np.zeros_like(T)
    solve_lith = np.array(True)

    matrix.scale(-1.0)
    self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
    dT_ad = dT[:]
    
    nl = len(self.lithology_index)
    for i in range(0, nl):
        idx = self.lithology_mask[i]
        idx_n = np.logical_and(idx, dT_ad != 0.0)
        ng = idx_n.any()
        comm.Allreduce([ng, MPI.BOOL], [solve_lith, MPI.BOOL], op=MPI.LOR)
        if solve_lith:
            self.mesh.diffusivity[:] = idx
            dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
            dAdklT = dAdkl * res._gdata
            self.ksp.solve(dAdklT, gvec)
            self.mesh.dm.globalToLocal(gvec, lvec)
            dk_ad[idx] += dT_ad.dot(lvec.array)/idx_n.sum()

    return dk_ad, db_ad.array</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Requires a tuple of vectors corresponding to an inversion variable
these are mapped to the mesh.</p>
<p>tuple(vec1, vec2, vecN) &ndash;&gt; tuple(field1, field2, fieldN)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, *args):
    &#34;&#34;&#34;
    Requires a tuple of vectors corresponding to an inversion variable
    these are mapped to the mesh.

    tuple(vec1, vec2, vecN) --&gt; tuple(field1, field2, fieldN)
    &#34;&#34;&#34;

    nf = len(args)
    nl = len(self.lithology_index)

    # preallocate memory
    mesh_variables = np.zeros((nf, self.lithology.size))

    # unpack vector to field
    for i in range(0, nl):
        idx = self.lithology_mask[i]
        for f in range(nf):
            mesh_variables[f,idx] = args[f][i]

    return list(mesh_variables)</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.map_ad"><code class="name flex">
<span>def <span class="ident">map_ad</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Map mesh variables back to the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_ad(self, *args):
    &#34;&#34;&#34;
    Map mesh variables back to the list
    &#34;&#34;&#34;
    
    nf = len(args)
    nl = len(self.lithology_index)

    lith_variables = np.zeros((nf, self.lithology_index.size))

    for i in range(0, nl):
        idx = self.lithology_mask[i]
        for f in range(nf):
            lith_variables[f,i] += args[f][idx].sum()

    return list(lith_variables)</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.objective_function"><code class="name flex">
<span>def <span class="ident">objective_function</span></span>(<span>self, x, x0, sigma_x0, ghost_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective_function(self, x, x0, sigma_x0, ghost_weight=1.0):
    x = np.ma.array(x, mask=np.isnan(x))
    C = (x - x0)**2/sigma_x0**2
    C *= ghost_weight
    return C.sum()</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.objective_function_ad"><code class="name flex">
<span>def <span class="ident">objective_function_ad</span></span>(<span>self, x, x0, sigma_x0, ghost_weight=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective_function_ad(self, x, x0, sigma_x0, ghost_weight=1.0):
    x = np.array(x)
    C_ad = (2.0*x - 2.0*x0)/sigma_x0**2
    C_ad *= ghost_weight
    return C_ad</code></pre>
</details>
</dd>
<dt id="conduction.inversion.inverse_conduction.Inversion.tangent_linear"><code class="name flex">
<span>def <span class="ident">tangent_linear</span></span>(<span>self, x, dx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tangent_linear(self, x, dx):
    hx, hy, hz = self.dx, self.dy, self.dz
    nx, ny, nz = self.nx, self.ny, self.nz

    k_list, H_list, a_list = np.array_split(x.array[:-1], 3)
    q0 = x.array[-1]
    dk_list, dH_list, da_list = np.array_split(dx.array[:-1], 3)
    dq0 = dx.array[-1]

    # Unpack vectors onto mesh
    k0, H, a = self.map(k_list, H_list, a_list)
    dk0, dH, da = self.map(dk_list, dH_list, da_list)

    

    dAdklT = self.mesh.gvec.duplicate()
    k = k0.copy()
    dk = dk0.copy()

    error_local  = np.array([True])
    error_global = np.ones(comm.size, dtype=bool)
    while error_global.any():
        k_last = k.copy()

        self.mesh.update_properties(k, H)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 298.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, q0, flux=True)
        A = self.mesh.construct_matrix()
        b = self.mesh.construct_rhs()

        self.ksp.solve(b._gdata, self.temperature)

        self.mesh.update_properties(dk, dH)
        self.mesh.boundary_condition(&#39;maxZ&#39;, 0.0, flux=False)
        self.mesh.boundary_condition(&#39;minZ&#39;, dq0, flux=True)
        dA = self.mesh.construct_matrix(in_place=False, derivative=True)
        db = self.mesh.construct_rhs(in_place=False)
        
        # dT = A-1*db - A-1*dA*A-1*b
        self.ksp.solve(db._gdata, self._temperature)


        A.scale(-1.0)

        x1 = dA*self.temperature
        self.ksp.solve(x1, self.mesh.gvec)

        self._temperature += self.mesh.gvec


        # dA.mult(self.temperature, self.mesh.gvec)
        # self.ksp.solve(self.mesh.gvec, dT_2)

        # for lith in self.lithology_index:
        #     idx = self.lithology == lith
        #     self.mesh.diffusivity.fill(0.0)
        #     self.mesh.diffusivity[idx] = 1.0
        #     dAdkl = self.mesh.construct_matrix(in_place=False, derivative=True)
        #     dAdkl.mult(self.temperature, dAdklT)
        #     self.ksp.solve(dAdklT, self.mesh.gvec)
        #     dT_2.array[idx] = self.mesh.gvec.array[idx]



        self.mesh.dm.globalToLocal(self.temperature, self.mesh.lvec)
        T = self.mesh.lvec.array.copy()
        self.mesh.dm.globalToLocal(self._temperature, self.mesh.lvec)
        dT = self.mesh.lvec.array.copy()

        dkda = np.log(298.0/T)*k0*(298.0/T)**a
        dkdk0 = (298.0/T)**a
        dkdT = -a*k0/T*(298.0/T)**a

        k = k0*(298.0/T)**a
        dk = dkda*da + dkdk0*dk0 + dkdT*dT

        error_local[0] = np.absolute(k - k_last).max() &gt; 1e-6
        comm.Allgather([error_local, MPI.BOOL], [error_global, MPI.BOOL])



    cost = np.array(0.0)
    sum_cost = np.array(0.0)
    dc = np.array(0.0)
    sum_dc = np.array(0.0)

    # Cost observations
    if &#39;q&#39; in self.observation:
        obs = self.observation[&#39;q&#39;]

        # Compute heat flux
        gradTz, gradTy, gradTx = np.gradient(T.reshape(self.mesh.n), *self.mesh.grid_coords[::-1])
        heatflux = -k.reshape(self.mesh.n)*(gradTz + gradTy + gradTx)
        q_interp = heatflux.ravel()
        
        if obs[2] is not None:
            self.interp.values = heatflux
            q_interp = self.interp(obs[2], method=&#39;nearest&#39;)
        cost += self.objective_function(q_interp, obs[0], obs[1], obs[-1])

        # dqdT = k
        dqdTz = -k/(nz*hz)
        dqdTy = -k/(ny*hy)
        dqdTx = -k/(nx*hx)
        dqdk = -(gradTz + gradTy + gradTx)

        # dq = dqdT*dT + dqdk.ravel()*dk
        dq = dqdTz*dT + dqdTy*dT + dqdTx*dT + dqdk.ravel()*dk
        dq_interp = dq
        if obs[2] is not None:
            self.interp.values = dq.reshape(self.mesh.n)
            dq_interp = self.interp(obs[2], method=&#39;nearest&#39;)
        # print obs[-1], &#34;\n&#34;, q_interp, &#34;\n&#34;, dq_interp
        dcdq = self.objective_function_ad(q_interp, obs[0], obs[1], obs[-1])
        # print &#34;tl&#34;, dcdq
        dc += np.sum(dcdq*dq_interp)


    if &#39;T&#39; in self.observation:
        obs = self.observation[&#39;T&#39;]
        T_interp = T
        if obs[2] is not None:
            self.interp.values = T.reshape(self.mesh.n)
            T_interp = self.interp(obs[2], method=&#39;nearest&#39;)
        cost += self.objective_function(T_interp, obs[0], obs[1], obs[-1])

        dT_interp = dT
        if obs[2] is not None:
            self.interp.values = dT.reshape(self.mesh.n)
            dT_interp = self.interp(obs[2], method=&#39;nearest&#39;)
        dcdT = self.objective_function_ad(T_interp, obs[0], obs[1], obs[-1])
        dc += np.sum(dcdT*dT_interp)

    comm.Allreduce([cost, MPI.DOUBLE], [sum_cost, MPI.DOUBLE], op=MPI.SUM)
    comm.Allreduce([dc, MPI.DOUBLE], [sum_dc, MPI.DOUBLE], op=MPI.SUM)


    # Cost priors
    for key, array, darray in [(&#39;k&#39;,k_list, dk_list),
                               (&#39;H&#39;,H_list, dH_list),
                               (&#39;a&#39;,a_list, da_list),
                               (&#39;q0&#39;,q0,dq0)]:

        if key in self.prior:
            prior = self.prior[key]
            sum_cost += self.objective_function(array, prior[0], prior[1])

            dcdp = self.objective_function_ad(array, prior[0], prior[1])
            sum_dc += np.sum(dcdp*darray)


    return sum_cost, sum_dc</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="conduction.inversion" href="index.html">conduction.inversion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="conduction.inversion.inverse_conduction.Inversion" href="#conduction.inversion.inverse_conduction.Inversion">Inversion</a></code></h4>
<ul class="">
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.add_observation" href="#conduction.inversion.inverse_conduction.Inversion.add_observation">add_observation</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.add_observation_new" href="#conduction.inversion.inverse_conduction.Inversion.add_observation_new">add_observation_new</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.add_prior" href="#conduction.inversion.inverse_conduction.Inversion.add_prior">add_prior</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.add_prior_new" href="#conduction.inversion.inverse_conduction.Inversion.add_prior_new">add_prior_new</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.adjoint" href="#conduction.inversion.inverse_conduction.Inversion.adjoint">adjoint</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.cost" href="#conduction.inversion.inverse_conduction.Inversion.cost">cost</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.cost_ad" href="#conduction.inversion.inverse_conduction.Inversion.cost_ad">cost_ad</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.forward_model" href="#conduction.inversion.inverse_conduction.Inversion.forward_model">forward_model</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.gradient" href="#conduction.inversion.inverse_conduction.Inversion.gradient">gradient</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.gradient_ad" href="#conduction.inversion.inverse_conduction.Inversion.gradient_ad">gradient_ad</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.heatflux" href="#conduction.inversion.inverse_conduction.Inversion.heatflux">heatflux</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.heatflux_ad" href="#conduction.inversion.inverse_conduction.Inversion.heatflux_ad">heatflux_ad</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.interpolate" href="#conduction.inversion.inverse_conduction.Inversion.interpolate">interpolate</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.linear_solve" href="#conduction.inversion.inverse_conduction.Inversion.linear_solve">linear_solve</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.linear_solve_ad" href="#conduction.inversion.inverse_conduction.Inversion.linear_solve_ad">linear_solve_ad</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.map" href="#conduction.inversion.inverse_conduction.Inversion.map">map</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.map_ad" href="#conduction.inversion.inverse_conduction.Inversion.map_ad">map_ad</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.objective_function" href="#conduction.inversion.inverse_conduction.Inversion.objective_function">objective_function</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.objective_function_ad" href="#conduction.inversion.inverse_conduction.Inversion.objective_function_ad">objective_function_ad</a></code></li>
<li><code><a title="conduction.inversion.inverse_conduction.Inversion.tangent_linear" href="#conduction.inversion.inverse_conduction.Inversion.tangent_linear">tangent_linear</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>